import argparse
import cmd2

from typing import List
import re

from precon.maps import MapsParser
from precon.maps import MapsAnalyzer
from precon.adb_helper import ADB
from precon.process import AppProcess
from precon.process import MemoryBlob


class Session(cmd2.Cmd):

    def __init__(self):
        super().__init__()
        self.regions = None
        self.blobs = None

    diff_parser = cmd2.Cmd2ArgumentParser()
    base_diff_parsers = diff_parser.add_subparsers(
        title='Resource Diffing',
        help='Performs various diffing analyses of various resources to identify common memory structures.'
    )

    def __find_apps(self, app_names: List[str]) -> List[str]:
        apps = []
        for app_name in app_names:
            try:
                app_candidates = ADB.find_app(app_name)
                if len(app_candidates) > 1:
                    self.perror(f'App name pattern \'{app_name}\' matches multiple apps:')
                    for app in app_candidates:
                        self.perror(f'  {app}')
                    return None
                elif len(app_candidates) == 0:
                    self.perror(f'App name pattern \'{app_name}\' does not match any apps.')
                    return None
                apps.append(app_candidates[0])
            except RuntimeError as e:
                self.perror(f'Failed to look up \'{app_name}\': {e}')
                return None
        return apps

    # --- Subcommand: App Diffing
    app_diff_parser = base_diff_parsers.add_parser('app', help='App Maps Diffing')
    app_diff_parser.add_argument('-c', '--count', type=int, default=2, help='Amount of maps files to compare per app.')
    app_diff_parser.add_argument('-n', '--names', nargs='+', type=str, help='Pattern name of app to analyze.')

    def do_app_diff(self, args):

        # Get arguments
        count = args.count
        if count <= 1:
            self.perror(f'Invalid count: {count} >= 2.')
            return None
        app_names = args.names

        # Find app
        apps = self.__find_apps(app_names)
        if apps is None:
            return None
        
        # Download maps files and perform maps diffing.
        regions = None
        for app in apps:
            try:
                if regions is None:
                    regions = MapsAnalyzer.find_common_regions_remote(app, count - 1)
                else:
                    # Need to diff with next regions list.
                    regions = MapsAnalyzer.diff_regions(regions, MapsAnalyzer.find_common_regions_remote(app, count - 1))
            except RuntimeError as e:
                self.perror(f'Failed to download and compare maps files of \'{app}\': {e}.')
                # Propbably burned a lot of memory, so free it
                regions = None
                import gc
                gc.collect()
                return None

        self.regions = regions
        
        # Prompt success
        success = cmd2.ansi.style(f'Successfully compared {count * len(apps)} maps files of apps \'{apps}\'. Found {len(self.regions)} shared regions.', fg=cmd2.ansi.Fg.GREEN)
        self.poutput(success)
    app_diff_parser.set_defaults(func=do_app_diff)


    # --- Subcommand: Region Diffing
    region_diff_parser = base_diff_parsers.add_parser('region', help='Memory Region Diffing')
    region_diff_parser.add_argument('-c', '--count', type=int, default=2, help='Amount of regions to pull from each app.')
    region_diff_parser.add_argument('-r', '--region-base', type=str, help='Base address of region to diff (hex).')
    region_diff_parser.add_argument('-n', '--names', nargs='+', type=str, help='Pattern name of apps to pull regions from.')
    region_diff_parser.add_argument('-m', '--min-blob-size', type=int, default=0x4, help='Minimum number of bytes that make up a blob. Reduces matches by chance.')

    def do_region_diff(self, args):
        count = args.count
        if isinstance(args.region_base, str):
            region_base = int(args.region_base, 16)
        app_names = args.names
        min_blob_size = args.min_blob_size

        if self.regions is None:
            self.perror('Invalid session state. Run \'diff app...\' first.')
            return None

        if count <= 1:
            self.perror(f'Invalid count: {count} >= 2.')
            return None

        if min_blob_size < 1:
            self.perror(f'Invalid minimum blob size: {min_blob_size} >= 1.')
            return None

        matching_regions = [ region for region in self.regions if region.addr_start == region_base ]
        if len(matching_regions) == 0:
            self.perror(f'Region at \'{hex(region_base)}\' is not part of maps diff.')
            return None
        elif len(matching_regions) > 1:
            self.perror(f'Region at \'{hex(region_base)}\' matches more than one region:')
            for matched in matching_regions:
                self.perror(f'  {matched}')
            return None
        region = matching_regions[0]

        # Find apps
        apps = self.__find_apps(app_names)
        if apps is None:
            return None

        # Need to fetch data from regions over multiple app restarts.
        # Incrementally compare regions.

        blobs: List[MemoryBlob] = None
        for app in apps:
            for _ in range(count):
                self.poutput(f'Diffing app \'{app}\'.')
                try:
                    ADB.restart_app(app, block=True)
                    pid = ADB.get_app_pid(app)
                    self.poutput(f'App \'{app}\' has PID {pid}.')
                except RuntimeError as e:
                    self.perror(f'Failed to restart app \'{app}\'.')
                    return None
                
                process = AppProcess.from_pid(pid)

                try:
                    if blobs is None:
                        blobs = [ process.get_region_data(region) ]
                        continue

                    # There are already blobs.
                    other: MemoryBlob = process.get_region_data(region)

                    survivors: List[MemoryBlob] = []
                    for blob in blobs:

                        offset: int = blob.addr_start - region.addr_start

                        current_blob_offset: int = 0
                        current_blob_size: int = 0
                        for i in range(len(blob.data)):

                            # Compare with other region
                            if blob.data[i] != other.data[offset + i]:
                                if current_blob_size >= min_blob_size:
                                    # Found end of matching blob
                                    survivors.append(
                                        MemoryBlob(
                                            region.addr_start + current_blob_offset,
                                            blob.data[current_blob_offset:current_blob_offset+current_blob_size]
                                        )
                                    )
                                    current_blob_size = 0
                                current_blob_offset = i + 1
                            else:
                                current_blob_size += 1

                        # Is entire blob identical?
                        if current_blob_size == len(blob.data):
                            survivors.append(blob)

                    blobs = survivors
                        
                except RuntimeError as e:
                    self.perror(f'Failed to get region data of \'{region}\' in app \'{app}\': {e}.')
                    return None

        # Finally set blobs
        self.blobs = blobs

        success = cmd2.ansi.style(f'Found {len(self.blobs)} matching blob(s).', fg=cmd2.ansi.Fg.GREEN)
        self.poutput(success)

        return None
    region_diff_parser.set_defaults(func=do_region_diff)

    # --- Base command: Diffing
    @cmd2.with_argparser(diff_parser)
    def do_diff(self, args):
        func = getattr(args, 'func', None)
        if func is not None:
            func(self, args)
        else:
            self.do_help('diff')

    search_parser = cmd2.Cmd2ArgumentParser()
    base_search_parsers = search_parser.add_subparsers(
        title='Resource Search',
        help='Allows searching resources queried with the \'diff\' command.'
    )
    
    # --- Subcommand: App Maps Searching
    maps_search_parser = base_search_parsers.add_parser('maps', help='App Maps Searching')
    maps_search_parser.add_argument('-r', '--regex', type=str, default='.*', help='Regex pattern to match on regions from maps files.')

    def do_maps_search(self, args):
        # Check and get args
        if self.regions is None:
            self.perror('Invalid session state. Run \'diff app...\' command first.')
            return None
        pattern = args.regex

        # Match pattern on each record
        for region in self.regions:
            if re.match(pattern, region.__str__()) is not None:
                self.poutput(region.__str__())
    maps_search_parser.set_defaults(func=do_maps_search)


    # --- Subcommand: Blob Searching
    blob_search_parser = base_search_parsers.add_parser('blobs', help='Blob Searching')
    blob_search_parser.add_argument('-r', '--regex', type=str, default='.*', help='Regex pattern to match on blobs.')

    def do_blob_search(self, args):
        # Check and get args
        if self.blobs is None:
            self.perror('Invalid session state. Run \'diff region...\' command first.')
            return None
        pattern = args.regex

        # Match pattern on each record
        for blob in self.blobs:
            if re.match(pattern, blob.__str__()) is not None:
                self.poutput(blob.__str__())
    blob_search_parser.set_defaults(func=do_blob_search)


    # --- Base command: Searching
    @cmd2.with_argparser(search_parser)
    def do_search(self, args):
        func = getattr(args, 'func', None)
        if func is not None:
            func(self, args)
        else:
            self.do_help('search')

    frida_parser = cmd2.Cmd2ArgumentParser()
    base_frida_parsers = frida_parser.add_subparsers(
        title='Frida Helpers',
        help='Allows calling a variety of Frida scripts.'
    )

    # --- Subcommand: Frida Objects
    frida_hook_parser = base_frida_parsers.add_parser('objects', help='List objects using Frida hooking.')
    frida_hook_parser.add_argument('-i', '--pid', type=int, default=-1, help='PID of process to hook into.')
    frida_hook_parser.add_argument('-n', '--app-name', type=str, default='', help='Name of app to hook. App name is preferred over PID.')
    frida_hook_parser.add_argument('-a', '--amount', type=int, default=0, help='Amount of objects to find via hooking.')
    frida_hook_parser.add_argument('-c', '--cls', type=str, help='Full class name of objects to find.')
    frida_hook_parser.add_argument('-m', '--method', type=str, help='Full method name of method that is expected to be called on objects.')
    frida_hook_parser.add_argument('-p', '--params', nargs='*', default=[], type=str, help='Parameter types of method to hook (for overloaded methods).')

    def do_frida_objects(self, args):
        amount = args.amount
        cls = args.cls
        method = args.method
        params = args.params
        app_name = args.app_name
        pid = args.pid

        if pid <= -1 and len(app_name) == 0:
            self.perror(f'Must specify PID or app name.')
            return None

        # Find process
        try:
            process = None
            if len(app_name) > 0:
                process = AppProcess.from_app_name(app_name)
            else:
                process = AppProcess.from_pid(pid)

            objects = process.get_nobjects_calling(cls, method, params, amount)
            for obj in objects:
                self.poutput(obj.__str__())

        except RuntimeError as e:
            self.perror(e.__str__())
            return None

    frida_hook_parser.set_defaults(func=do_frida_objects)

    # --- Base command: Frida
    @cmd2.with_argparser(frida_parser)
    def do_frida(self, args):
        func = getattr(args, 'func', None)
        if func is not None:
            func(self, args)
        else:
            self.do_help('frida')

    file_parser = cmd2.Cmd2ArgumentParser()
    base_file_parsers = file_parser.add_subparsers(
        title='In - Process File Parsing',
        help='Enables to map file structures onto memory regions.'
    )

    # --- Subcommand: File .art
    art_file_parser = base_file_parsers.add_parser('art', help='Map .art file structure to memory region.')
    art_file_parser.add_argument('-a', '--address', type=str, help='Base address of memory region (base 16).')
    art_file_parser.add_argument('-s', '--size', type=str, help='Size of memory region (base 16).')
    art_file_parser.add_argument('-n', '--app-name', type=str, default='', help='Name of app to hook. App name is preferred over PID.')

    def do_file_art(self, args):
        address = int(args.address, 16)
        size = int(args.size, 16)
        app_name = args.app_name

        # Get process
        try:
            process = AppProcess.from_app_name(app_name)
            art_file = process.map_art_file(address, size)

            self.poutput(art_file.image_header().__str__())
            self.poutput(art_file.section_class_table().__str__())

            for obj in art_file.image_roots():
                self.poutput(f'  {obj}')

        except RuntimeError as e:
            self.perror(e.__str__())


    art_file_parser.set_defaults(func=do_file_art)

    # --- Base command: File
    @cmd2.with_argparser(file_parser)
    def do_file(self, args):
        func = getattr(args, 'func', None)
        if func is not None:
            func(self, args)
        else:
            self.do_help('file')



    # --- Base command: Eval
    eval_parser = cmd2.Cmd2ArgumentParser('Evaluate Python Expressions')
    eval_parser.add_argument('-e', '--expression', type=str, help='Python expression to evaluate.')
    @cmd2.with_argparser(eval_parser)
    def do_eval(self, args):
        expr = args.expression
        self.poutput(eval(expr))


def main():
    # Simple interactive loop
    import sys
    session = Session()
    sys.exit(session.cmdloop())


if __name__ == '__main__':
    main()