# Source: https://gist.github.com/fxthomas/3c915909bbf84bc14782cb6adef0f915

import re
import gc
from dataclasses import dataclass

from pathlib import Path
import tempfile

import subprocess
from os import linesep
import time
import sys

from typing import List
from typing import Union
from typing import Set
from typing import Optional


ADB_PATH = 'adb'


def app_to_activity_name(app_name: str) -> str:
    return run_adb_shell_command(('dumpsys window | '
        'grep -o "Window{.*}" | '
        f'grep "{app_name}" | '
        'tr [:blank:] \\\\t | '
        'tr -d "{}" | '
        'cut -f3 | '
        'head -n 1'))


def app_to_pid(app_name: str) -> int:
    return int(run_adb_shell_command(f'pidof {app_name}'))


def download_maps(pid: int, output_name: str) -> None:
    run_adb_shell_command(f'su -c cp /proc/{pid}/maps /data/local/tmp/maps')
    run_adb_command(['pull', '/data/local/tmp/maps', output_name])
    run_adb_shell_command('su -c rm /data/local/tmp/maps')


@dataclass
class App:
    app_installation_path: str
    app_name: str
    main_activity_name: str
    activities: List[str]
    uid: str


class ADB:
    @classmethod
    def run(cls, command: Union[str, List[str]]) -> str:
        if isinstance(command, str):
            command = ['shell', command]

        process = subprocess.Popen([ADB_PATH] + command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        process.wait()
        stdout, stderr = process.communicate()
        if len(stderr) > 0:
            raise RuntimeError(stderr.decode('utf-8'))
        return stdout.decode('utf-8')

    @classmethod
    def find_app(cls, pattern: str) -> List[str]:
        packages: List[str] = [ line.split(':')[1] for line in ADB.run('pm list packages').split(linesep) if ':' in line ]
        return [
            package
            for package in packages
            if re.match(pattern, package)
        ]

    @classmethod
    def get_app_pid(cls, app_name: str) -> Optional[int]:
        pid = ADB.run(f'pidof {app_name}')
        if not pid or len(pid) == 0:
            # Expected error: app is not running
            return None
        return int(pid, 10)

    @classmethod
    def get_app_uid(cls, app_name: str) -> str:
        uid = ADB.run(f'pm list packages -U {app_name}')
        if not uid or len(uid) == 0:
            raise RuntimeError(f'Cannot find uid for app \'{app_name}\'.')
        return uid.split(':')[-1]

    @classmethod
    def get_app_main_activity(cls, app_name: str) -> str:
        TODO('Implement correctly, not just heuristically.')
        main = ADB.run(f'dumpsys package {app_name}')
        if not main or len(main) == 0:
            raise RuntimeError(f'Cannot find main activity for app \'{app_name}\'.')

        return [
            candidate
            for candidate in re.sub(r'\s+', ' ', main).split(' ')
            if f'{app_name}/' in candidate
        ][0].split('/')[1]


    @classmethod
    def get_app_activities(cls, app_name: str) -> List[str]:
        TODO('Figure out a way to get all activities of a specific app.')
        return []

    @classmethod
    def get_app_installation_path(cls, app_name: str) -> str:
        path = ADB.run(f'pm path {app_name}')
        if not path or len(path) == 0:
            raise RuntimeError(f'Cannot find path for app \'{app_name}\'.')
        return ''.join(path.split(':')[1:])

    @classmethod
    def load_app(cls, app_name: str) -> App:
        return App(
            app_installation_path=ADB.get_app_installation_path(app_name),
            app_name=app_name,
            main_activity_name=ADB.get_app_main_activity(app_name),
            activities=ADB.get_app_activities(app_name),
            uid=ADB.get_app_uid(app_name)
        )

    @classmethod
    def pull(cls, path: Path, output_path: Path) -> None:
        path = path.absolute()
        output_path = output_path.absolute()
        tmp_path = Path('/data/local/tmp/tmp')
        ADB.run(f'su -c cp {path.as_posix()} {tmp_path.as_posix()}')
        ADB.run(['pull', tmp_path, output_path.as_posix()])
        ADB.run(f'su -c rm {tmp_path.as_posix()}')

    @classmethod
    def version(cls) -> str:
        version = ADB.run([ 'version' ])
        if not version or len(version) == 0:
            raise RuntimeError(f'Cannot query ADB version.')
        return version

    @classmethod
    def get_app_name(cls, pid: int) -> str:
        return re.sub(r'\s+', ' ', ADB.run(f'ps -e | grep {pid}')).strip().split(' ')[-1]

    @classmethod
    def start_app(cls, app_name: str, activity_name: str) -> None:
        ADB.run(f'am start -n {app_name}/{activity_name}')

    @classmethod
    def restart_app(cls, app_name: str, block: bool=False) -> None:
        ADB.run(f'am force-stop {app_name}')
        ADB.start_app(app_name, ADB.get_app_main_activity(app_name))
        
        if block:
            done = False
            while not done:
                try:
                    ADB.get_app_pid(app_name)
                    done = True
                except:
                    pass
                time.sleep(0.1)


MAPS_LINE_RE = re.compile(r"""
    (?P<addr_start>[0-9a-f]+)-(?P<addr_end>[0-9a-f]+)\s+  # Address
    (?P<perms>\S+)\s+                                     # Permissions
    (?P<offset>[0-9a-f]+)\s+                              # Map offset
    (?P<dev>\S+)\s+                                       # Device node
    (?P<inode>\d+)\s+                                     # Inode
    (?P<pathname>.*)\s+                                   # Pathname
""", re.VERBOSE)


def human_bytes(size):
    modifier = 1
    while size > 1024:
        modifier *= 1024
        size /= 1024
    return "%.1f%s" % (size, {
        1024**0: 'b',
        1024**1: 'k',
        1024**2: 'M',
        1024**3: 'G',
        1024**4: 'T',
    }.get(modifier, " x%d" % modifier))


@dataclass()
class Record:
    addr_start: int
    addr_end: int
    perms: str
    offset: int
    dev: str
    inode: int
    pathname: str

    def __init__(self, addr_start: int, addr_end: int, perms: str, offset: int, dev: str, inode: str, pathname: str):
        self.addr_start = int(addr_start, 16)
        self.addr_end = int(addr_end, 16)
        self.perms = perms
        self.offset = int(offset, 16)
        self.dev = dev
        self.inode = int(inode, 10)
        self.pathname = pathname

    def __str__(self) -> str:
        return f'{hex(self.addr_start)} - {hex(self.addr_end)} (offset: {hex(self.offset)}): {self.pathname} ({self.perms})'

    @property
    def size(self) -> int:
        return self.addr_end - self.addr_start

    @property
    def human_size(self) -> str:
        return human_bytes(self.size)

    @property
    def readable(self) -> bool:
        return self.perms[0] == "r"

    @property
    def writable(self) -> bool:
        return self.perms[1] == "w"

    @property
    def executable(self) -> bool:
        return self.perms[2] == "x"

    @property
    def shared(self) -> bool:
        return self.perms[3] == "s"

    @property
    def private(self) -> bool:
        return self.perms[3] == "p"


class MapsParser:
    @classmethod
    def parse(cls, lines: List[str]) -> List[Record]:
        return [
            Record(*m.groups())
            for line in lines
            if (m := MAPS_LINE_RE.match(line)) is not None
        ]

    @classmethod
    def parse_remote(cls, id: Union[int, str]) -> List[Record]:
        """
        Parameters
        ----------
        id: int or string
            If `id` is integer, then it will be interpreted as a PID. Else,
            if `id` is string, then it will be interpreted as an app name.
        """
        if isinstance(id, int):
            pid = id
        elif isinstance(id, str):
            pid = ADB.get_app_pid(id)
            if not pid:
                raise RuntimeError(f'App \'{id}\' is not running or cannot be found.')
        else:
            raise RuntimeError(f'Invalid app identifier \'{id}\'.')
        
        # Pull maps file
        out_path = Path(tempfile.mktemp())
        ADB.pull(Path(f'/proc/{pid}/maps'), out_path)
        try:
            with open(out_path.as_posix(), 'r') as fd:
                return MapsParser.parse(fd.readlines())
        finally:
            if out_path.exists():
                out_path.unlink()
        
        raise RuntimeError(f'Failed to process {id}.')


class MapsAnalyzer:

    @classmethod
    def find_common_regions_remote(cls, id: Union[int, str], amount_comparisons: int=9) -> List[Record]:
        if amount_comparisons < 1:
            raise RuntimeError(f'Amount of comparisons ({amount_comparisons}) must be at least 1.')

        # Initially, the PID can be used to query the app name.
        # However, the PID does not persist over app restarts.
        if isinstance(id, int):
            app_name = ADB.get_app_name(id)
        elif isinstance(id, str):
            app_name = id
        else:
            raise RuntimeError(f'App id \'{id}\' is invalid.')

        ADB.restart_app(app_name, block=True)
        regions = MapsParser.parse_remote(app_name)
        for _ in range(amount_comparisons):
            ADB.restart_app(app_name, block=True)
            regions = MapsAnalyzer.diff_regions(regions, MapsParser.parse_remote(app_name))

        return regions

    @classmethod
    def diff_regions(cls, lhs: List[Record], rhs: List[Record]) -> List[Record]:
        """Performs lhs = lhs - rhs in terms of set difference.
        """
        return [
            lhs[lhs.index(r)]
            for r in rhs
            if r in lhs
        ]


def main(pids: List[int]):
    regions: List[Record] = None
    for pid in pids:
        if not regions:
            regions = MapsParser.parse_remote(pid)
        else:
            regions = MapsAnalyzer.diff_regions(regions, MapsParser.parse_remote(pid))
    
    print('Found common regions:')
    for i, region in enumerate(regions):
        print(f'[{i:04}]: {region}')
    print(f'Total: {len(regions)}')


if __name__ == '__main__':
    # Usage: python3 ./<me>.py <pid1> <pid2>
    args = sys.argv
    if len(args) != 3:
        print(f'Invalid usage: {args[0]} <pid1> <pid2>')
        sys.exit(0)

    pids: List[int] = []
    try:
        pids += [
            int(arg, 10)
            for arg in args[1:]
        ]
    except:
        print(f'PIDs must be integer to base 10.')
        sys.exit(0)
    
    main(pids)