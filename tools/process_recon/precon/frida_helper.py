import frida

from dataclasses import dataclass

from threading import Event

import json

from typing import Optional


@dataclass
class FridaJSFunction:
    name: str
    function: str


class FridaScripts:

    @classmethod
    def snippet_iterate_modules(cls, callback: str, data: str) -> str:
        '''Constructs a Frida JavaScript code snippet to iterate modules. Each module is
        passed to the `callback`. If the callback returns `true`, then iteration will continue.
        Otherwise, if `callback` returns `false`, then iteration will stop. `data` is
        passed in as an additional argument to the callback.
        '''
        return f'''
            const modules = Process.enumerateModules();
            const callback = {callback};
            const data = {data};
            for (let module_id in modules) {{
                const module = modules[module_id];
                if (module == null) {{
                    continue;
                }}

                if (!callback(module, data)) {{
                    break;
                }}
            }}
        '''

    @classmethod
    def function_get_module_by_name(cls) -> FridaJSFunction:
        '''Constructs a Frida JavaScript function named `get_module_by_name`.
        If the `module_name` is found, then a module object will be returned.
        Otherwise, `null` is returned.
        '''
        name = 'get_module_by_name'
        data = f'{ name: \'{module_name}\', module: null }'
        callback = f'''
            function(module, data) {{
                if (module.name == data.name) {{
                    // Stop on matching module name.
                    data.module = module;
                    return false;
                }}
                return true;
            }}
        '''
        return FridaJSFunction(name, f'''
            function {name}(module_name) {{
                const data = {data};
                {FridaScripts.snippet_iterate_modules(callback, 'data')}
                return data.module;
            }}
        ''')

    @classmethod
    def function_read_memory(cls) -> FridaJSFunction:
        ''''''
        name = 'read_memory'

        return FridaJSFunction(name, f'''
            function {name}(address, size) {{
                return ptr(address).readByteArray(size);
            }}
        ''')

    @classmethod
    def function_write_memory(cls) -> FridaJSFunction:
        ''''''
        name = 'write_memory'

        return FridaJSFunction(name, f'''
            function {name}(address, buffer) {{
                ptr(address).writeByteArray(buffer);
            }}
        ''')


@dataclass
class FridaModule:
    name: str
    base: int
    size: int
    path: str

    def __init__(name: str, base: str, size: int, path: str) -> None:
        self.name = name
        self.base = int(base, 16)
        self.size = size
        self.path = path


class FridaHelper:

    @classmethod
    def find_module_base_by_name(cls, pid: int, module_name: str, old_session: frida.core.Session=None, stay_attached: bool=False) -> Optional[FridaModule]:

        try:
            if old_session is None:
                device = frida.get_usb_device()
                session = device.attach(pid)
            else:
                session = old_session

            event = Event()
            module = None

            def on_message(message, data):
                if message['type'] == 'error':
                    raise RuntimeError(f'Retrieving module failed: {message}')
                elif message['type'] == 'send':
                    module = json.loads(message['payload'])
                    event.set()
                else:
                    raise RuntimeError(f'Unknown message type: {message}.')

            function_get_module_by_name = FridaScript.function_get_module_by_name()
            script = session.create_script(f'''
                // Create module search function.
                {function_get_module_by_name.function}

                // Then call it
                const module = {function_get_module_by_name.name}({module_name});
                if (module == null) {{
                    send({{
                        type: 'error',
                        message: 'Failed to find module {module_name}.'
                    }});
                }} else {{
                    send(module);
                }}
            ''')
            script.on('message', on_message)
            script.load()
            event.wait()

            return FridaModule(**module)

        except frida.ServerNotRunningError as e:
            raise RuntimeError(e.__str__())
        finally:
            if not stay_attached:
                session.detach()