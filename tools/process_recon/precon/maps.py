# Source: https://gist.github.com/fxthomas/3c915909bbf84bc14782cb6adef0f915

import re
import gc
from dataclasses import dataclass

from pathlib import Path
import tempfile

from typing import List
from typing import Union
from typing import Set

from .adb_helper import ADB


MAPS_LINE_RE = re.compile(r"""
    (?P<addr_start>[0-9a-f]+)-(?P<addr_end>[0-9a-f]+)\s+  # Address
    (?P<perms>\S+)\s+                                     # Permissions
    (?P<offset>[0-9a-f]+)\s+                              # Map offset
    (?P<dev>\S+)\s+                                       # Device node
    (?P<inode>\d+)\s+                                     # Inode
    (?P<pathname>.*)\s+                                   # Pathname
""", re.VERBOSE)


def human_bytes(size):
    modifier = 1
    while size > 1024:
        modifier *= 1024
        size /= 1024
    return "%.1f%s" % (size, {
        1024**0: 'b',
        1024**1: 'k',
        1024**2: 'M',
        1024**3: 'G',
        1024**4: 'T',
    }.get(modifier, " x%d" % modifier))


@dataclass()
class Record:
    addr_start: int
    addr_end: int
    perms: str
    offset: int
    dev: str
    inode: int
    pathname: str

    def __init__(self, addr_start: int, addr_end: int, perms: str, offset: int, dev: str, inode: str, pathname: str):
        self.addr_start = int(addr_start, 16)
        self.addr_end = int(addr_end, 16)
        self.perms = perms
        self.offset = int(offset, 16)
        self.dev = dev
        self.inode = int(inode, 10)
        self.pathname = pathname

    def __str__(self) -> str:
        return f'{hex(self.addr_start)} - {hex(self.addr_end)} (offset: {hex(self.offset)}): {self.pathname} ({self.perms})'

    @property
    def size(self) -> int:
        return self.addr_end - self.addr_start

    @property
    def human_size(self) -> str:
        return human_bytes(self.size)

    @property
    def readable(self) -> bool:
        return self.perms[0] == "r"

    @property
    def writable(self) -> bool:
        return self.perms[1] == "w"

    @property
    def executable(self) -> bool:
        return self.perms[2] == "x"

    @property
    def shared(self) -> bool:
        return self.perms[3] == "s"

    @property
    def private(self) -> bool:
        return self.perms[3] == "p"


class MapsParser:
    @classmethod
    def parse(cls, lines: List[str]) -> List[Record]:
        return [
            Record(*m.groups())
            for line in lines
            if (m := MAPS_LINE_RE.match(line)) is not None
        ]

    @classmethod
    def parse_remote(cls, id: Union[int, str]) -> List[Record]:
        """
        Parameters
        ----------
        id: int or string
            If `id` is integer, then it will be interpreted as a PID. Else,
            if `id` is string, then it will be interpreted as an app name.
        """
        if isinstance(id, int):
            pid = id
        elif isinstance(id, str):
            pid = ADB.get_app_pid(id)
            if not pid:
                raise RuntimeError(f'App \'{id}\' is not running or cannot be found.')
        else:
            raise RuntimeError(f'Invalid app identifier \'{id}\'.')
        
        # Pull maps file
        out_path = Path(tempfile.mktemp())
        ADB.pull(Path(f'/proc/{pid}/maps'), out_path)
        try:
            with open(out_path.as_posix(), 'r') as fd:
                return MapsParser.parse(fd.readlines())
        finally:
            if out_path.exists():
                out_path.unlink()
        
        raise RuntimeError(f'Failed to process {id}.')


class MapsAnalyzer:

    @classmethod
    def find_common_regions_remote(cls, id: Union[int, str], amount_comparisons: int=9) -> List[Record]:
        if amount_comparisons < 1:
            raise RuntimeError(f'Amount of comparisons ({amount_comparisons}) must be at least 1.')

        # Initially, the PID can be used to query the app name.
        # However, the PID does not persist over app restarts.
        if isinstance(id, int):
            app_name = ADB.get_app_name(id)
        elif isinstance(id, str):
            app_name = id
        else:
            raise RuntimeError(f'App id \'{id}\' is invalid.')

        ADB.restart_app(app_name, block=True)
        regions = MapsParser.parse_remote(app_name)
        for _ in range(amount_comparisons):
            ADB.restart_app(app_name, block=True)
            regions = MapsAnalyzer.diff_regions(regions, MapsParser.parse_remote(app_name))

        return regions

    @classmethod
    def diff_regions(cls, lhs: List[Record], rhs: List[Record]) -> List[Record]:
        """Performs lhs = lhs - rhs in terms of set difference.
        """
        return [
            lhs[lhs.index(r)]
            for r in rhs
            if r in lhs
        ]