from .adb_helper import App
from .adb_helper import ADB
from .maps import Record

from .frida_helper import FridaHelper
from .frida_helper import FridaScripts
from .art_file import ArtFile

import frida
from threading import Event
from dataclasses import dataclass

import logging
from typing import List

from abc import ABC
from abc import abstractmethod

import struct
import ctypes
from ctypes import c_uint8
from ctypes import c_uint16
from ctypes import c_uint32
from ctypes import c_uint64


@dataclass
class MemoryBlob:
    addr_start: int
    data: bytes

    def __str__(self) -> str:
        return f'{hex(self.addr_start)} - {hex(self.addr_start + len(self.data))} (size: {hex(len(self.data))})'


@dataclass
class Hook:
    script: object


class JavaObject:
    address: int


class Memory(ABC):

    @abstractmethod
    def base(self) -> int:
        raise NotImplementedError()

    @abstractmethod
    def global_read(self, address: int, size: int) -> bytes:
        '''Reads `size` bytes starting at `address`.
        '''
        raise NotImplementedError()

    @abstractmethod
    def is_little_endian(self) -> bool:
        '''Returns `True`, if the memory uses little endian; `False` otherwise.
        '''
        raise NotImplementedError()

    @abstractmethod
    def close(self) -> None:
        raise NotImplementedError()

    def read(self, offset: int, size: int) -> bytes:
        '''Reads `size` bytes starting at `offset` relative to the `self.base()`.
        '''
        return self.global_read(self.base() + offset, size)

    def is_big_endian(self) -> bool:
        return not self.is_little_endian()

    def __endian_prefix(self) -> str:
        return '<' if self.is_little_endian() else '>'

    def __unpack_format(self, size: int) -> int:
        prefix = self.__endian_prefix()
        s = None
        if size == 1:
            s = 'B'
        elif size == 2:
            s = 'H'
        elif size == 4:
            s = 'I'
        elif size == 8:
            s = 'Q'
        else:
            raise NotImplementedError(f'Size {size} is not supported.')
        return prefix + s
    
    def __unpack(self, data: bytes) -> int:
        return struct.unpack(self.__unpack_format(len(data)), data)[0]

    def read_u8(self, offset: int) -> int:
        return self.__unpack(self.read(offset, ctypes.sizeof(c_uint8)))

    def read_u16(self, offset: int) -> bytes:
        return self.__unpack(self.read(offset, ctypes.sizeof(c_uint16)))

    def read_u32(self, offset: int) -> bytes:
        return self.__unpack(self.read(offset, ctypes.sizeof(c_uint32)))

    def read_u64(self, offset: int) -> bytes:
        return self.__unpack(self.read(offset, ctypes.sizeof(c_uint64)))

    def global_read_u8(self, address: int) -> int:
        return self.__unpack(self.global_read(address, ctypes.sizeof(c_uint8)))

    def global_read_u16(self, address: int) -> bytes:
        return self.__unpack(self.global_read(address, ctypes.sizeof(c_uint16)))

    def global_read_u32(self, address: int) -> bytes:
        return self.__unpack(self.global_read(address, ctypes.sizeof(c_uint32)))

    def global_read_u64(self, address: int) -> bytes:
        return self.__unpack(self.global_read(address, ctypes.sizeof(c_uint64)))


class FridaBackedMemory(Memory):

    def __init__(self, address: int, size: int, pid: int=-1, session: frida.core.Session=None) -> None:
        self.start = address
        self.end = self.start + size
        try:
            if session is not None:
                self.session = session
            else:
                assert (pid >= 0)
                device = frida.get_usb_device()
                self.session: frida.core.Session = device.attach(pid)

            self.read_event: Event = Event()
            self.data: bytes = None
            self.done: bool = False

            # Build up read primitive script

            def on_message(message, data):
                if message['type'] == 'send':
                    # Received answer to read request
                    self.data = data
                    self.read_event.set()

            read = FridaScripts.function_read_memory()
            self.script = self.session.create_script(f'''
                setTimeout(function() {{
                    // Read function
                    {read.function}
                    
                    // On message handler
                    function onMessage(message) {{
                        // Got read request: blob = {{address: x, size: y}}
                        const blob = message['payload'];
                        const data = {read.name}(blob.address, blob.size);

                        // Send data back to requester.
                        send(null, data);
                    }}

                    // Repeatedly listen for read requests until done.
                    while (true) {{
                        // Receive message
                        const message = recv('memory', onMessage);
                        
                        // Block until message arrives.
                        message.wait();
                    }}
                }});
            ''')
            self.script.on('message', on_message)
            self.script.load()

        except frida.ServerNotRunningError as e:
            raise RuntimeError(e.__str__())

    def base(self) -> int:
        return self.start

    def read(self, offset: int, size: int) -> bytes:
        address = self.base() + offset
        if not (self.start <= address and address + size < self.end):
            raise RuntimeError(f'Out - of - bounds memory read at {hex(address)} with size {hex(size)}.')
        return self.global_read(address, size)

    def global_read(self, address: int, size: int) -> bytes:
        self.script.post({'type': 'memory', 'payload': {'address': address, 'size': size}})
        self.read_event.wait()
        self.read_event.clear()
        data = self.data
        self.data = None
        return data

    def is_little_endian(self) -> bool:
        return True

    def close(self) -> None:
        if self.script is not None:
            self.script.unload()
            self.script = None
        if self.session is not None:
            self.session.detach()
            self.session = None


class AppProcess:

    def __init__(self, app: App, pid: int) -> None:
        self.app = app
        self.pid = pid
        self.session = None
        self.current_hook_id = 0
        self.hooks = {
            # Format: id (int) -> hook (Hook)
        }

    def get_region_data(self, region: Record) -> MemoryBlob:
        # Use Frida to extract data from process image.
        self.attach_frida()

        try:
            event = Event()
            region_size = region.addr_end - region.addr_start
            blob = MemoryBlob(region.addr_start, b'')
            def on_message(message, data):
                if message['type'] == 'send':
                    blob.data += data
                    if len(blob.data) == region_size:
                        event.set()
                elif message['type'] == 'error':
                    print(message['stack'])
                
            script = self.session.create_script(f'''
                const chunk_size = 0x1000;
                for (let address = {region.addr_start}; address < {region.addr_end}; address += chunk_size) {{
                    const data = ptr(address).readByteArray(chunk_size);
                    send('DATA', data);
                }}
            ''')
            script.on('message', on_message)
            script.load()

            event.wait()
            if len(blob.data) != region_size:
                raise RuntimeError(f'Failed to load region data from \'{region.__str__()}\': Loaded {hex(len(blob.data))} bytes, but region is of size {hex(region_size)}.')
            return blob
        finally:
            # Unload script
            script.unload()


    def add_java_hook(self, class_name: str, method_name: str, params: List[str], callback: str, on_message_callback) -> int:
        '''Hooks Java method of class with given names.

        `callback` is a JavaScript method that is given
        1. `this`
        and returns a boolean that indicates whether to call (true) the actual implementation or not (false).
        At best, the callback is a non - arrow function, like `function() {code here}`.

        `params` is a list of parameter types used to identify overloaded methods. If the method
        is unique, simply pass an empty list.
        '''
        self.attach_frida()

        def on_message(message, data):
            if message['type'] == 'error':
                raise RuntimeError(f'Failed to hook method: {message["payload"]}')
            elif message['type'] == 'send':
                logging.info(message['payload'])
            else:
                logging.debug(f'Receiving unhandled message type: {message}')

        if not on_message_callback:
            on_message_callback = on_message

        script = self.session.create_script(f'''
            setTimeout(function() {{
                Java.perform(function() {{
                    // Try to find class by name.
                    const Class = Java.use('{class_name}');
                    if (Class == null) {{
                        send({{
                            type: 'error',
                            message: 'Failed to find class {class_name}.'
                        }});
                        return;
                    }}

                    // Try to find method
                    let method = Class.{method_name}.overload({', '.join([ '"' + param + '"' for param in params])});
                    if (method == null) {{
                        send({{
                            type: 'error',
                            message: 'Failed to find method {method_name} with parameter types ({params}).'
                        }});
                        return;
                    }}

                    // Got method, now hook it.
                    const callback = {callback};
                    method.implementation = function() {{
                        if (callback(this, arguments)) {{
                            this.{method_name}(...arguments);
                        }}
                    }};
                }});
            }});
        ''')
        script.on('message', on_message_callback)
        script.load()

        hook = Hook(script)
        self.hooks[self.current_hook_id] = hook
        self.current_hook_id += 1
        return self.current_hook_id - 1

    def remove_hook(self, hook_id: int) -> None:
        if not hook_id or hook_id not in self.hooks:
            return
        del self.hooks[hook_id]

    def get_nobjects_calling(self, class_name: str, method_name: str, params: List[str], amount: int) -> List[JavaObject]:
        # Use Frida to hook method name. `amount` is the number of objects to
        # find using the hook.
        assert (amount >= 0)
        if amount == 0:
            return []

        objects: List[JavaObject] = []

        event = Event()

        class Counter:
            i: int = 0
        
        counter = Counter()

        def on_message(message, data):
            if message['type'] == 'send':
                objects.append(message['payload'])
                logging.info(message['payload'])
                counter.i += 1

                if counter.i == amount:
                    event.set()
            elif message['type'] == 'error':
                logging.error(message['stack'])

        hook_id = None
        try:
            hook_id = self.add_java_hook(class_name, method_name, params, f'''
                function(context, args) {{
                    // Use context to extract register information.
                    for (let arg in args) {{
                        console.log(arg);
                    }}
                    return true;
                }}
            ''', on_message)
        finally:
            self.remove_hook(hook_id)
            self.detach_frida()

        event.wait()
        assert (len(objects) == amount)
        return objects

    def memory(self, address: int, size: int) -> Memory:
        # Use Frida to provide memory access to entire process image.
        return FridaBackedMemory(pid=self.pid, address=address, size=size)

    def map_art_file(self, address: int, size: int) -> ArtFile:
        # Use Frida to dump memory of boot.art
        # module_name = '/system/framework/arm64/boot.art'
        # module = FridaHelper.find_module_base_by_name(self.pid, module_name)
        # if module is None:
        #     raise RuntimeError(f'Module {module_name} cannot be found.')

        # Now parse .art file from memory. Do this in memory! Do not download file.
        return ArtFile(self.memory(address, size))

    def is_frida_attached(self) -> bool:
        return self.session is not None

    def attach_frida(self) -> None:
        if self.is_frida_attached():
            return
        try:
            device = frida.get_usb_device()
            self.session = device.attach(self.pid)
            assert (self.session is not None)
        except frida.ServerNotRunningError as e:
            raise RuntimeError(e.__str__())

    def detach_frida(self) -> None:
        if not self.is_frida_attached():
            return
        self.session.detach()
        self.session = None

    @classmethod
    def from_pid(cls, pid: int) -> 'Process':
        assert (pid is not None)
        if pid < 0:
            raise RuntimeError(f'PID must be non - negative: {pid} >= 0.')
        app_name = ADB.get_app_name(pid)
        if app_name is None:
            raise RuntimeError(f'Failed to find app package name with PID {pid}.')
        app = ADB.load_app(app_name)
        return AppProcess(app, pid)

    @classmethod
    def from_app_name(cls, app_name: str) -> 'Process':
        assert (app_name is not None)
        pid = ADB.get_app_pid(app_name)
        if pid is None:
            raise RuntimeError(f'Failed to find process with name {app_name}.')
        app = ADB.load_app(app_name)
        return AppProcess(app, pid)
