import subprocess
import re
from os import linesep

from typing import List
from typing import Union
from typing import Optional

from dataclasses import dataclass

from pathlib import Path
import time

from .util import TODO


ADB_PATH = 'adb'


def app_to_activity_name(app_name: str) -> str:
    return run_adb_shell_command(('dumpsys window | '
        'grep -o "Window{.*}" | '
        f'grep "{app_name}" | '
        'tr [:blank:] \\\\t | '
        'tr -d "{}" | '
        'cut -f3 | '
        'head -n 1'))


def app_to_pid(app_name: str) -> int:
    return int(run_adb_shell_command(f'pidof {app_name}'))


def download_maps(pid: int, output_name: str) -> None:
    run_adb_shell_command(f'su -c cp /proc/{pid}/maps /data/local/tmp/maps')
    run_adb_command(['pull', '/data/local/tmp/maps', output_name])
    run_adb_shell_command('su -c rm /data/local/tmp/maps')


@dataclass
class App:
    app_installation_path: str
    app_name: str
    main_activity_name: str
    activities: List[str]
    uid: str


class ADB:

    @classmethod
    def run(cls, command: Union[str, List[str]]) -> str:
        if isinstance(command, str):
            command = ['shell', command]

        process = subprocess.Popen([ADB_PATH] + command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        process.wait()
        stdout, stderr = process.communicate()
        if len(stderr) > 0:
            raise RuntimeError(stderr.decode('utf-8'))
        return stdout.decode('utf-8')

    @classmethod
    def find_app(cls, pattern: str) -> List[str]:
        packages: List[str] = [ line.split(':')[1] for line in ADB.run('pm list packages').split(linesep) if ':' in line ]
        return [
            package
            for package in packages
            if re.match(pattern, package)
        ]

    @classmethod
    def get_app_pid(cls, app_name: str) -> Optional[int]:
        pid = ADB.run(f'pidof {app_name}')
        if not pid or len(pid) == 0:
            # Expected error: app is not running
            return None
        return int(pid, 10)

    @classmethod
    def get_app_uid(cls, app_name: str) -> str:
        uid = ADB.run(f'pm list packages -U {app_name}')
        if not uid or len(uid) == 0:
            raise RuntimeError(f'Cannot find uid for app \'{app_name}\'.')
        return uid.split(':')[-1]

    @classmethod
    def get_app_main_activity(cls, app_name: str) -> str:
        TODO('Implement correctly, not just heuristically.')
        main = ADB.run(f'dumpsys package {app_name}')
        if not main or len(main) == 0:
            raise RuntimeError(f'Cannot find main activity for app \'{app_name}\'.')

        return [
            candidate
            for candidate in re.sub(r'\s+', ' ', main).split(' ')
            if f'{app_name}/' in candidate
        ][0].split('/')[1]


    @classmethod
    def get_app_activities(cls, app_name: str) -> List[str]:
        TODO('Figure out a way to get all activities of a specific app.')
        return []

    @classmethod
    def get_app_installation_path(cls, app_name: str) -> str:
        path = ADB.run(f'pm path {app_name}')
        if not path or len(path) == 0:
            raise RuntimeError(f'Cannot find path for app \'{app_name}\'.')
        return ''.join(path.split(':')[1:])

    @classmethod
    def load_app(cls, app_name: str) -> App:
        return App(
            app_installation_path=ADB.get_app_installation_path(app_name),
            app_name=app_name,
            main_activity_name=ADB.get_app_main_activity(app_name),
            activities=ADB.get_app_activities(app_name),
            uid=ADB.get_app_uid(app_name)
        )

    @classmethod
    def pull(cls, path: Path, output_path: Path) -> None:
        path = path.absolute()
        output_path = output_path.absolute()
        tmp_path = Path('/data/local/tmp/tmp')
        ADB.run(f'su -c cp {path.as_posix()} {tmp_path.as_posix()}')
        ADB.run(['pull', tmp_path, output_path.as_posix()])
        ADB.run(f'su -c rm {tmp_path.as_posix()}')

    @classmethod
    def version(cls) -> str:
        version = ADB.run([ 'version' ])
        if not version or len(version) == 0:
            raise RuntimeError(f'Cannot query ADB version.')
        return version

    @classmethod
    def get_app_name(cls, pid: int) -> str:
        return re.sub(r'\s+', ' ', ADB.run(f'ps -e | grep {pid}')).strip().split(' ')[-1]

    @classmethod
    def start_app(cls, app_name: str, activity_name: str) -> None:
        ADB.run(f'am start -n {app_name}/{activity_name}')

    @classmethod
    def restart_app(cls, app_name: str, block: bool=False) -> None:
        ADB.run(f'am force-stop {app_name}')
        ADB.start_app(app_name, ADB.get_app_main_activity(app_name))
        
        if block:
            done = False
            while not done:
                try:
                    ADB.get_app_pid(app_name)
                    done = True
                except:
                    pass
                time.sleep(0.1)