from .util import pretty_print

import struct
import ctypes
from ctypes import Structure
from enum import IntEnum
from ctypes import c_uint8
from ctypes import c_uint16
from ctypes import c_uint32
from ctypes import c_uint64
from ctypes import c_int32
from ctypes import c_double

import pprint

from abc import ABC
from abc import abstractmethod

from typing import Optional
from typing import List

from dataclasses import dataclass

class Class(Structure):
    _fields_ = [
        ('declaring_class_', c_uint32),
        ('monitor_', c_uint32),
        ('class_loader_', c_uint32),
        ('component_type_', c_uint32),
        ('dex_cache_', c_uint32),
        ('ext_data_', c_uint32),
        ('iftable_', c_uint32),
        ('name_', c_uint32),
        ('super_class_', c_uint32),
        ('vtable_', c_uint32),
        ('ifields_', c_uint64),
        ('methods_', c_uint64),
        ('sfields_', c_uint64),
        ('access_flags_', c_uint32),
        ('class_flags_', c_uint32),
        ('class_size_', c_uint32),
        ('clinit_thread_id_', c_int32),
        ('dex_class_def_idx_', c_int32),
        ('dex_type_idx_', c_int32),
        ('num_reference_instance_fields_', c_uint32),
        ('num_reference_static_fields_', c_uint32),
        ('object_size_', c_uint32),
        ('object_size_alloc_fast_path_', c_uint32),
        ('primitive_types_', c_uint32),
        ('reference_instance_offsets_', c_uint32),
        ('status_', c_uint32),
        ('copied_methods_offset_', c_uint16),
        ('virtual_methods_offset_', c_uint16)
    ]

    def __init__(self) -> None:
        self.declaring_class_ = 0
        self.monitor_ = 0
        self.virtual_methods_offset_ = 0
        self.copied_methods_offset_ = 0
        self.status_ = 0
        self.reference_instance_offsets_ = 0
        self.primitive_types_ = 0
        self.object_size_alloc_fast_path_ = 0
        self.object_size_ = 0
        self.num_reference_static_fields_ = 0
        self.num_reference_instance_fields_ = 0
        self.dex_type_idx_ = 0
        self.dex_class_def_idx_ = 0
        self.clinit_thread_id_ = 0
        self.class_size_ = 0
        self.class_flags_ = 0
        self.access_flags_ = 0
        self.sfields_ = 0
        self.methods_ = 0
        self.ifields_ = 0
        self.vtable_ = 0
        self.super_class_ = 0
        self.name_ = 0
        self.iftable_ = 0
        self.ext_data_ = 0
        self.dex_cache_ = 0
        self.component_type_ = 0
        self.class_loader_ = 0

    def build(self) -> bytes:
        return bytes(self)

    def __str__(self) -> str:
        # return pprint.pformat(_get_dict(self), indent=4)
        return pretty_print(self)

    def size() -> int:
        return ctypes.sizeof(Class)


# Source: https://cs.android.com/android/platform/superproject/main/+/main:art/runtime/oat/image.h;l=49;drc=a7ba109ec6c7c1ca82f96651863b3d2c10c6bc34
class ImageSection(Structure):
    _fields_ = [
        ('offset_', c_uint32),
        ('size_', c_uint32),
    ]

    def __str__(self) -> str:
        return pretty_print(self)


class PointerSize(IntEnum):
    k32 = 4
    k64 = 8

  
# This describes the number and ordering of sections inside of Boot
# and App Images.  It is very important that changes to this struct
# are reflected in the compiler and loader.
#
# See:
#   - ImageWriter::ImageInfo::CreateImageSections()
#   - ImageWriter::Write()
#   - ImageWriter::AllocMemory()
class ImageSections(IntEnum):
    kSectionObjects = 0
    kSectionArtFields = 1
    kSectionArtMethods = 2
    kSectionImTables = 3
    kSectionIMTConflictTables = 4
    kSectionRuntimeMethods = 5
    kSectionJniStubMethods = 6
    kSectionInternedStrings = 7
    kSectionClassTable = 8
    kSectionStringReferenceOffsets = 9
    kSectionDexCacheArrays = 10
    kSectionMetadata = 11
    kSectionImageBitmap = 12
    kSectionCount = 13


class ImageMethod(IntEnum):
    kResolutionMethod = 0
    kImtConflictMethod = 1
    kImtUnimplementedMethod = 2
    kSaveAllCalleeSavesMethod = 3
    kSaveRefsOnlyMethod = 4
    kSaveRefsAndArgsMethod = 5
    kSaveEverythingMethod = 6
    kSaveEverythingMethodForClinit = 7
    kSaveEverythingMethodForSuspendCheck = 8
    kImageMethodsCount = 9


class ImageHeader(Structure):
    _fields_ = [
        ('magic_', c_uint8 * 4),
        ('version_', c_uint8 * 4),
        ('image_reservation_size_', c_uint32),
        ('component_count_', c_uint32),
        ('image_begin_', c_uint32),
        ('image_size_', c_uint32),
        ('image_checksum_', c_uint32),
        ('oat_checksum_', c_uint32),
        ('oat_file_begin_', c_uint32),
        ('oat_data_begin_', c_uint32),
        ('oat_data_end_', c_uint32),
        ('oat_file_end_', c_uint32),
        ('boot_image_begin_', c_uint32),
        ('boot_image_size_', c_uint32),
        ('boot_image_component_count_', c_uint32),
        ('boot_image_checksum_', c_uint32),
        ('image_roots_', c_uint32),
        ('pointer_size_', c_uint32),
        ('sections_', ImageSection * ImageSections.kSectionCount),
        ('image_methods_', c_uint64 * ImageMethod.kImageMethodsCount),
        ('data_size_', c_uint32),
        ('blocks_offset_', c_uint32),
        ('blocks_counts_', c_uint32),
    ]

    def __str__(self) -> str:
        return f'size = {hex(ctypes.sizeof(ImageHeader))}' + pretty_print(self)


# Source: https://cs.android.com/android/platform/superproject/main/+/main:art/runtime/runtime_image.cc;l=1782;drc=9bdd4361b613b8e45cc412254bb35cbcd5789904
# Basically, these are simple objects.
class SectionObjects:

    def __init__(self, raw: bytes, memory: object) -> None:
        # Idea:
        # 1. Check current_obj->class->object_size
        # 2. Skip to next object
        # Stop heuristically: If the above pointer chain does not work

        # Objects should lie at the very beginning already
        self.objects = []
        unpack_format = ('<' if memory.is_little_endian() else '>') + 'I'
        obj_off = 0
        obj_size_off = ctypes.sizeof(c_uint32) * (10 + 8) + ctypes.sizeof(c_uint64) * (3)
        while obj_off < len(raw):

            # 1. Read class pointer
            cls_ptr: int = struct.unpack(unpack_format, raw[obj_off:obj_off+ctypes.sizeof(c_uint32)])[0]
            print(f'Class Pointer: {hex(cls_ptr)}')
            if cls_ptr == 0:
                # May be Object class or first invalid encounter.
                # Object class is assumed to be unique.
                break

            # Figure out object size
            cls: Class = Class.from_buffer_copy(memory.global_read(cls_ptr, ctypes.sizeof(Class)))
            obj_size: int = struct.unpack(unpack_format, memory.global_read(cls_ptr + obj_size_off, ctypes.sizeof(c_uint32)))[0]
            if obj_size < 8:
                # Invalid object size
                break

            # Up to this point, the pointer chain has been traversed successfully, so object is assumed to be valid.
            self.objects.append(raw[obj_off:obj_off+obj_size])

            # Eventually increment the object pointer
            obj_off += obj_size

    def __str__(self) -> str:
        s = '{\n'
        for i, obj in enumerate(self.objects):
            s += f'  {i}: {obj}\n'
        return s + '}'

    @classmethod
    def from_buffer_copy(cls, buffer: bytes, memory: 'Memory') -> 'SectionObject':
        return SectionObjects(buffer, memory)


class ClassTableSlot(Structure):
    _fields_ = [
        ('data_', c_uint32)
    ]

    def __str__(self) -> str:
        return pretty_print(self)


# Source: https://cs.android.com/android/platform/superproject/main/+/main:art/libartbase/base/hash_set.h;l=355;drc=9bdd4361b613b8e45cc412254bb35cbcd5789904
class SectionClassTable:

    class __ClassTable(Structure):

        _fields_ = [
            ('num_elements_', c_uint64),
            ('num_buckets_', c_uint64),
            ('elements_until_expand_', c_uint64),
            ('min_load_factor_', c_double),
            ('max_load_factor_', c_double),
        ]

    def __init__(self, raw: bytes) -> None:
        data_offset = ctypes.sizeof(SectionClassTable.__ClassTable)
        class_table = SectionClassTable.__ClassTable.from_buffer_copy(raw[:data_offset])

        self.num_elements_ = class_table.num_elements_
        self.num_buckets_ = class_table.num_buckets_
        self.elements_until_expand_ = class_table.elements_until_expand_
        self.min_load_factor_ = class_table.min_load_factor_
        self.max_load_factor_ = class_table.max_load_factor_

        slot_size = ctypes.sizeof(ClassTableSlot)
        self.data_ = [
            ClassTableSlot.from_buffer_copy(raw[data_offset+i*slot_size:data_offset+(i+1)*slot_size])
            for i in range(self.num_buckets_)
        ]

    @classmethod
    def from_buffer_copy(cls, buffer: bytes) -> 'SectionClassTable':
        return SectionClassTable(buffer)


@dataclass
class JavaObject:
    type_name: str
    address: int
    data: bytes

    def __str__(self) -> str:
        return f'{{ type: {self.type_name}, address: {hex(self.address)}, data: {self.data} }}'

    
class ArtFile:

    def __init__(self, backing_memory: 'Memory') -> None:
        assert (backing_memory is not None)
        self.__memory: 'Memory' = backing_memory

        # Caching
        self.__image_header: ImageHeader = None
        self.__class_table: SectionClassTable = None
        self.__objects: SectionObjects = None

    def image_header(self) -> ImageHeader:
        if self.__image_header is not None:
            return self.__image_header

        # Otherwise parse from data.
        raw = self.__memory.read(0, ctypes.sizeof(ImageHeader))
        self.__image_header = ImageHeader.from_buffer_copy(raw)
        assert (self.__image_header is not None)
        return self.__image_header

    def section_objects(self) -> Optional[SectionObjects]:
        if self.__objects is not None:
            return self.__objects

        # Parse objects
        section = self.image_section_by_index(ImageSections.kSectionObjects)
        if section.size_ == 0:
            return None

        raw = self.__memory.read(section.offset_ + ctypes.sizeof(ImageHeader) + 0x10, section.size_)
        assert (raw is not None)
        assert (len(raw) == section.size_)
        self.__objects = SectionObjects.from_buffer_copy(raw, self.__memory)
        assert (self.__objects is not None)
        return self.__objects

    def image_roots(self) -> List[JavaObject]:
        image_roots = self.image_header().image_roots_
        if image_roots == 0:
            return []
        
        # Traverse image roots. It is known that the initial object
        # pointed to by image_roots is an Object[]. Thus, remember
        # that declaring class pointer to identify deeper layers of
        # this object tree.
        object_array_class = self.__memory.global_read_u32(image_roots)
        if object_array_class == 0:
            # It is either Object or an error.
            return []

        obj_size_off = ctypes.sizeof(c_uint32) * (10 + 8) + ctypes.sizeof(c_uint64) * (3)
        type_name_off = ctypes.sizeof(c_uint32) * 7

        def __traverse_image_roots(root_ptr: int) -> List[JavaObject]:
        
            # Object array starts with length, which is followed by a list
            # of objects (32-bit).
            length = self.__memory.global_read_u32(root_ptr + 8)
            if length <= 0:
                return []

            print(f'Root: {hex(root_ptr)}, Length: {hex(length)}')
            
            results = []
            for i in range(length):
                obj = self.__memory.global_read_u32(root_ptr + 0xc + i * 4)

                declaring_class = self.__memory.global_read_u32(obj)
                if declaring_class == object_array_class:
                    # Object may be an Object[], i.e. next layer of tree
                    results += __traverse_image_roots(obj)
                elif declaring_class == 0:
                    # Object can be class Object or invalid.
                    pass
                else:
                    # Any other class, which is interesting for analysis.
                    object_size = self.__memory.global_read_u32(declaring_class + obj_size_off)
                    data = self.__memory.global_read(obj, object_size)

                    # Try to get type name, if any.
                    type_name_ptr = self.__memory.global_read_u32(declaring_class + type_name_off)
                    if type_name_ptr != 0:
                        type_name_length = self.__memory.global_read_u32(type_name_ptr + 0x8) // 2
                        type_name = self.__memory.global_read(type_name_ptr + 0x10, type_name_length)
                    else:
                        type_name = '<unknown>'

                    results.append(JavaObject(type_name, obj, data))
            
            return results
        
        return __traverse_image_roots(image_roots)

    def section_class_table(self) -> Optional[SectionClassTable]:
        if self.__class_table is not None:
            return self.__class_table

        # Parse class table
        section = self.image_section_by_index(ImageSections.kSectionClassTable)
        if section.size_ == 0:
            return None

        # Source: https://cs.android.com/android/platform/superproject/main/+/main:art/runtime/runtime_image.cc;l=186;drc=9bdd4361b613b8e45cc412254bb35cbcd5789904
        raw = self.__memory.read(section.offset_ + ctypes.sizeof(ImageHeader), section.size_)
        assert (raw is not None)
        assert (len(raw) == section.size_)
        self.__class_table = SectionClassTable.from_buffer_copy(raw)
        assert (self.__class_table is not None)
        return self.__class_table

    def image_section_by_index(self, index: int) -> ImageSection:
        image_header = self.image_header()
        assert (index < len(image_header.sections_))
        return image_header.sections_[index]

    def close(self) -> None:
        self.__memory.close()
        self.__memory = None

    def __str__(self) -> str:
        return pretty_print(self)


class ArtFileParser:
    @classmethod
    def from_data(cls, data: bytes) -> ImageHeader:
        return ImageHeader.from_buffer_copy(data)