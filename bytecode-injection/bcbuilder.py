from pwn import p8
from pwn import p16
from pwn import p32
from pwn import p64

from typing import Dict
from typing import List

import math


class BytecodeBuilder:
    def __init__(self, type_map: Dict[str, int]={}) -> None:
        self.__bytecode = b''
        self.__type_map = type_map
        for type_name in self.__type_map:
            self.__check_u16(self.__type_map[type_name])

    def build(self) -> bytes:
        return self.__bytecode

    # def new_instance(self, destination_register: int, type_index: int) -> 'BytecodeBuilder':
    def new_instance(self, destination_register: int, type_name: str) -> 'BytecodeBuilder':
        self.__check_u8(destination_register)
        self.__check_type(type_name)
        type_index = self.__type_map[type_name]
        self.__append_bytecode(
            b'\x22' + p8(destination_register, signed=False) + p16(type_index, signed=False),
            4
        )
        return self

    def __invoke_kind(self, opcode: bytes, argument_word_count: int, method_reference_index: int, argument_registers: List[int]) -> 'BytecodeBuilder':
        # Format: <bytecode><count (4) | G (4)><index (16)><D (4) | C (4)><F (4) | E (4)>
        self.__check_u4(argument_word_count)
        self.__check_u16(method_reference_index)

        # regs[0] = <C>, ..., regs[4] = <G>
        regs = [ 0 for _ in range(5) ]
        for i in range(len(argument_registers)):
            self.__check_u4(argument_registers[i])
            regs[i] = argument_registers[i]

        self.__append_bytecode(
            opcode +
            self.__p44(regs[4], argument_word_count) +
            p16(method_reference_index, signed=False) +
            self.__p44(regs[0], regs[1]) +
            self.__p44(regs[2], regs[3]),
            6
        )
        return self

    def invoke_virtual(self, argument_word_count: int, method_reference_index: int, argument_registers: List[int]) -> 'BytecodeBuilder':
        return self.__invoke_kind(b'\x6e', argument_word_count, method_reference_index, argument_registers)

    def invoke_super(self, argument_word_count: int, method_reference_index: int, argument_registers: List[int]) -> 'BytecodeBuilder':
        return self.__invoke_kind(b'\x6f', argument_word_count, method_reference_index, argument_registers)

    def invoke_direct(self, argument_word_count: int, method_reference_index: int, argument_registers: List[int]) -> 'BytecodeBuilder':
        return self.__invoke_kind(b'\x70', argument_word_count, method_reference_index, argument_registers)

    def invoke_static(self, argument_word_count: int, method_reference_index: int, argument_registers: List[int]) -> 'BytecodeBuilder':
        return self.__invoke_kind(b'\x71', argument_word_count, method_reference_index, argument_registers)
    
    def invoke_interface(self, argument_word_count: int, method_reference_index: int, argument_registers: List[int]) -> 'BytecodeBuilder':
        return self.__invoke_kind(b'\x72', argument_word_count, method_reference_index, argument_registers)

    def __move_result(self, opcode: bytes, destination_register: int) -> 'BytecodeBuilder':
        self.__check_u8(destination_register)
        self.__append_bytecode(opcode + p8(destination_register, signed=False), 2)
        return self

    def move_result(self, destination_register: int) -> 'BytecodeBuilder':
        return self.__move_result(b'\x0a', destination_register)
    
    def move_result_wide(self, destination_register: int) -> 'BytecodeBuilder':
        return self.__move_result(b'\x0b', destination_register)
    
    def move_result_object(self, destination_register: int) -> 'BytecodeBuilder':
        return self.__move_result(b'\x0c', destination_register)

    def __iput(self, opcode: bytes, source_register: int, object_register: int, instance_field_reference_index: int) -> 'BytecodeBuilder':
        # Format: <opcode><object_register | source_register><instance_field_reference_index>
        self.__check_u4(source_register)
        self.__check_u4(object_register)
        self.__check_u16(instance_field_reference_index)

        self.__append_bytecode(
            opcode + 
            self.__p44(source_register, object_register) + 
            p16(instance_field_reference_index, signed=False),
            4
        )
        return self

    def iput(self, source_register: int, object_register: int, instance_field_reference_index: int) -> 'BytecodeBuilder':
        return self.__iput(b'\x59', source_register, object_register, instance_field_reference_index)

    def iput_wide(self, source_register: int, object_register: int, instance_field_reference_index: int) -> 'BytecodeBuilder':
        return self.__iput(b'\x5a', source_register, object_register, instance_field_reference_index)

    def iput_object(self, source_register: int, object_register: int, instance_field_reference_index: int) -> 'BytecodeBuilder':
        return self.__iput(b'\x5b', source_register, object_register, instance_field_reference_index)

    def iput_boolean(self, source_register: int, object_register: int, instance_field_reference_index: int) -> 'BytecodeBuilder':
        return self.__iput(b'\x5c', source_register, object_register, instance_field_reference_index)

    def iput_byte(self, source_register: int, object_register: int, instance_field_reference_index: int) -> 'BytecodeBuilder':
        return self.__iput(b'\x5d', source_register, object_register, instance_field_reference_index)

    def iput_char(self, source_register: int, object_register: int, instance_field_reference_index: int) -> 'BytecodeBuilder':
        return self.__iput(b'\x5e', source_register, object_register, instance_field_reference_index)

    def iput_short(self, source_register: int, object_register: int, instance_field_reference_index: int) -> 'BytecodeBuilder':
        return self.__iput(b'\x5f', source_register, object_register, instance_field_reference_index)

    def __iget(self, opcode: bytes, destination_register: int, object_register: int, instance_field_reference_index: int) -> 'BytecodeBuilder':
        return self.__iput(opcode, destination_register, object_register, instance_field_reference_index)

    def iget(self, opcode: bytes, destination_register: int, object_register: int, instance_field_reference_index: int) -> 'BytecodeBuilder':
        return self.__iget(b'\x52', destination_register, object_register, instance_field_reference_index)

    def iget_wide(self, opcode: bytes, destination_register: int, object_register: int, instance_field_reference_index: int) -> 'BytecodeBuilder':
        return self.__iget(b'\x53', destination_register, object_register, instance_field_reference_index)

    def iget_object(self, opcode: bytes, destination_register: int, object_register: int, instance_field_reference_index: int) -> 'BytecodeBuilder':
        return self.__iget(b'\x54', destination_register, object_register, instance_field_reference_index)

    def iget_boolean(self, opcode: bytes, destination_register: int, object_register: int, instance_field_reference_index: int) -> 'BytecodeBuilder':
        return self.__iget(b'\x55', destination_register, object_register, instance_field_reference_index)

    def iget_byte(self, opcode: bytes, destination_register: int, object_register: int, instance_field_reference_index: int) -> 'BytecodeBuilder':
        return self.__iget(b'\x56', destination_register, object_register, instance_field_reference_index)

    def iget_char(self, opcode: bytes, destination_register: int, object_register: int, instance_field_reference_index: int) -> 'BytecodeBuilder':
        return self.__iget(b'\x57', destination_register, object_register, instance_field_reference_index)

    def iget_short(self, opcode: bytes, destination_register: int, object_register: int, instance_field_reference_index: int) -> 'BytecodeBuilder':
        return self.__iget(b'\x58', destination_register, object_register, instance_field_reference_index)

    # def new_array(self, destination_register: int, size_register: int, type_index) -> 'BytecodeBuilder':
    def new_array(self, destination_register: int, size_register: int, type_name: str) -> 'BytecodeBuilder':
        self.__check_u4(destination_register)
        self.__check_u4(size_register)
        self.__check_type(type_name)
        type_index = self.__type_map[type_name]
        self.__append_bytecode(
            b'\x23' + self.__p44(destination_register, size_register) + p16(type_index, signed=False),
            4
        )
        return self

    def fill_array_data(self, array_reference_register: int, offset_table: int) -> 'BytecodeBuilder':
        self.__check_u8(array_reference_register)
        self.__check_u32(offset_table)
        self.__append_bytecode(
            b'\x26' + p8(array_reference_register) + p32(offset_table, signed=True),
            6
        )
        return self

    def const_class(self, destination_register: int, type_name: str) -> 'BytecodeBuilder':
        self.__check_u8(destination_register)
        self.__check_type(type_name)
        type_index = self.__type_map[type_name]
        self.__append_bytecode(
            b'\x1c' + p8(destination_register) + p16(type_index, signed=False),
            4,
        )
        return self

    def const_4(self, destination_register: int, signed_value: int) -> 'BytecodeBuilder':
        self.__check_u4(destination_register)
        self.__check_u4(signed_value)
        self.__append_bytecode(
            b'\x12' + self.__p44(destination_register, signed_value),
            2
        )
        return self

    def const_16(self, destination_register: int, signed_value: int) -> 'BytecodeBuilder':
        self.__check_u8(destination_register)
        self.__check_u16(signed_value)
        self.__append_bytecode(
            b'\x13' + p8(destination_register) + p16(signed_value),
            4
        )
        return self

    def nop(self) -> 'BytecodeBuilder':
        self.__append_bytecode(b'\x00\x00', 2)
        return self

    def goto8(self, branch_offset: int) -> 'BytecodeBuilder':
        # self.__check_u8(branch_offset)
        # assert (branch_offset.bit_length() == 8), f'Branch offset {branch_offset} does not fit into 8 bits.'
        self.__append_bytecode(b'\x28' + p8(branch_offset, signed=True), 2)
        return self

    def move_wide16(self, destination_register_pair: int, source_register_pair: int) -> 'BytecodeBuilder':
        self.__check_u16(destination_register_pair)
        self.__check_u16(source_register_pair)
        self.__append_bytecode(
            b'\x06\x00' +
            p16(destination_register_pair, signed=False) +
            p16(source_register_pair, signed=False),
            6
        )
        return self

    def move_object16(self, destination_register: int, source_register: int) -> 'BytecodeBuilder':
        self.__check_u16(destination_register)
        self.__check_u16(source_register)
        self.__append_bytecode(
            b'\x09\x00' + 
            p16(destination_register, signed=False) +
            p16(source_register, signed=False),
            6
        )
        return self

    def __arrayop(self, prefix: bytes, dest_source_register: int, array_register: int, index_register: int) -> 'BytecodeBuilder':
        self.__check_u8(dest_source_register)
        self.__check_u8(array_register)
        self.__check_u8(index_register)

        self.__append_bytecode(
            prefix + 
            p8(dest_source_register, signed=False) +
            p8(array_register, signed=False) +
            p8(index_register, signed=False),
            4
        )
        return self

    def aput_wide(self, source_register: int, array_register: int, index_register: int) -> 'BytecodeBuilder':
        return self.__arrayop(b'\x4c', source_register, array_register, index_register)

    def aput_object(self, source_register: int, array_register: int, index_register: int) -> 'BytecodeBuilder':
        return self.__arrayop(b'\x4d', source_register, array_register, index_register)

    def aget_object(self, destination_register: int, array_register: int, index_register: int) -> 'BytecodeBuilder':
        return self.__arrayop(b'\x46', destination_register, array_register, index_register)

    def array_payload(self, element_width: int, size: int, data: bytes) -> 'BytecodeBuilder':
        self.__check_u16(element_width)
        self.__check_u32(size)
        assert (data is not None)
        assert (len(data) == element_width * size)
        self.__append_bytecode(
            p16(0x300) + p16(element_width) + p32(size) + data,
            2 + 2 + 4 + len(data)
        )
        return self

    def filled_new_array(self, array_size: int, type_name: str, argument_registers: List[int]) -> 'BytecodeBuilder':
        # Format: <opcode><size (4) | G (4)><index (16)><D (4) | C (4)><F (4) | E (4)>
        self.__check_u4(array_size)
        type_index = self.__type_map[type_name]
        regs = [0 for _ in range(5)]
        for i in range(len(argument_registers)):
            self.__check_u4(argument_registers[i])
            regs[i] = argument_registers[i]

        self.__append_bytecode(
            b'\x24' + 
            self.__p44(regs[4], array_size) +
            p16(type_index) +
            self.__p44(regs[0], regs[1]) +
            self.__p44(regs[2], regs[3]),
            6
        )
        return self

    def __binop(self, prefix: bytes, destination_register: int, first_source_register: int, second_source_register: int) -> 'BytecodeBuilder':
        self.__check_u8(destination_register)
        self.__check_u8(first_source_register)
        self.__check_u8(second_source_register)
        self.__append_bytecode(
            prefix + 
            p8(destination_register, signed=False) +
            p8(first_source_register, signed=False) +
            p8(second_source_register, signed=False),
            4
        )
        return self

    def add_int(self, destination_register_pair: int, first_source_register_pair: int, second_source_register_pair: int) -> 'BytecodeBuilder':
        return self.__binop(b'\x90', destination_register_pair, first_source_register_pair, second_source_register_pair)

    def add_long(self, destination_register_pair: int, first_source_register_pair: int, second_source_register_pair: int) -> 'BytecodeBuilder':
        return self.__binop(b'\x9b', destination_register_pair, first_source_register_pair, second_source_register_pair)

    def sub_int(self, destination_register_pair: int, first_source_register_pair: int, second_source_register_pair: int) -> 'BytecodeBuilder':
        return self.__binop(b'\x91', destination_register_pair, first_source_register_pair, second_source_register_pair)

    def sub_long(self, destination_register_pair: int, first_source_register_pair: int, second_source_register_pair: int) -> 'BytecodeBuilder':
        return self.__binop(b'\x9c', destination_register_pair, first_source_register_pair, second_source_register_pair)

    def const_wide(self, destination_register_pair: int, constant: int) -> 'BytecodeBuilder':
        self.__check_u8(destination_register_pair)
        self.__append_bytecode(
            b'\x18' + p8(destination_register_pair, signed=False) +
            p64(constant, signed=True),
            10
        )
        return self

    def return_void(self) -> 'BytecodeBuilder':
        self.__append_bytecode(b'\x0e\x00', 2)
        return self

    def __p44(self, lower: int, upper: int) -> bytes:
        self.__check_u4(lower)
        self.__check_u4(upper)
        return p8(lower | (upper << 4), signed=False)

    def __check_u4(self, value: int) -> None:
        self.__check_un(value, 0xf)

    def __check_u8(self, value: int) -> None:
        self.__check_un(value, 0xff)

    def __check_u16(self, value: int) -> None:
        self.__check_un(value, 0xffff)

    def __check_u32(self, value: int) -> None:
        self.__check_un(value, 0xffffffff)

    def __check_un(self, value: int, mask: int) -> None:
        assert ((value & mask) == value), f'Value {hex(value)} cannot be stored in {int(math.log2(mask + 1)) // 8} bytes.'
    
    def __check_type(self, type_str: str) -> None:
        assert (type_str in self.__type_map), f'Type name {type_str} is not defined in type map.'

    def __append_bytecode(self, new: bytes, expected_increase: int) -> None:
        assert (len(new) == expected_increase)
        self.__bytecode += new